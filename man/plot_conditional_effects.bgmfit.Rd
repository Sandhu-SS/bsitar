% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plot_conditional_effects.R
\name{plot_conditional_effects.bgmfit}
\alias{plot_conditional_effects.bgmfit}
\alias{plot_conditional_effects}
\title{Visualize conditional effects of predictor}
\usage{
\method{plot_conditional_effects}{bgmfit}(
  model,
  newdata = NULL,
  levels_id = NULL,
  resp = NULL,
  deriv = 0,
  deriv_model = TRUE,
  idata_method = "m1",
  verbose = FALSE,
  usesavedfuns = FALSE,
  clearenvfuns = FALSE,
  envir = NULL,
  ...
)

plot_conditional_effects(model, ...)
}
\arguments{
\item{model}{An object of class \code{bgmfit}.}

\item{newdata}{An optional data frame to be used in predictions. If
\code{NULL} (default), the model fit.}

\item{levels_id}{An optional argument to specify the \code{ids} for
hierarchical model (default \code{NULL}). It is used only when model is
applied to the data with 3 or more levels of hierarchy. For a two level
model, the \code{id} for second level is automatically inferred from the
model fit. Even for 3 or higher level model, ids are inferred from the
model fit but under the assumption that hierarchy is specified from
lower to upper levels i.e, \code{id} followed by \code{study} assuming that
\code{id} is nested within the \code{study} However, it is not guaranteed
that these ids are sorted correctly. Therefore, it is better to set them
manually.}

\item{resp}{A character string to specify response variable when processing
posterior draws for the univariate-by-subgroup and multivariate models (see
\code{\link[=bsitar]{bsitar()}} for details on fitting univariate-by-subgroup and
multivariate models). For univariate model, \code{resp = NULL} (default).
Note that argument \code{resp} must be specified for the
univariate-by-subgroup and multivariate models otherwise it will result in
an error. On the other hand, argument \code{resp} must be \code{NULL} for
the univariate model. The default setting is \code{resp = NULL} assuming a
univariate model.}

\item{deriv}{An integer to indicate whether to estimate distance curve or
derivatives (velocity and acceleration curves). Default \code{deriv = 0} is
for the distance curve, \code{deriv = 1} for velocity curve, and
\code{deriv = 2} for the acceleration curve.}

\item{deriv_model}{A logical (default \code{TRUE}) to indicate whether to
estimate model based derivatives or from the differentiation of the
distance curve. When model is fit with \code{decomp = 'QR'}, the only
approach available to estimate derivatives by the  differentiation of the
distance curve.}

\item{idata_method}{A character string to indicate the interpolation method.
The number of of interpolation points is set up the \code{ipts} argument.
Options available for \code{idata_method} are \emph{method 1} (specified as
\code{'m1'}, default) and \emph{method 2} (specified as \code{'m2'}). The
\emph{method 1} (\code{'m1'}) is adapted from the the \pkg{iapvbs} package
and is documented here
\url{https://rdrr.io/github/Zhiqiangcao/iapvbs/src/R/exdata.R}
whereas \emph{method 2} (\code{'m2'}) is based on the \pkg{JMbayes}
package as documented here
\url{https://github.com/drizopoulos/JMbayes/blob/master/R/dynPred_lme.R}.
The \code{'m1'} method works by internally constructing the data frame based
on the model configuration whereas the method \code{'m2'} uses the exact
data frame used in model fit and can be accessed via \code{fit$data}. If
\code{idata_method = NULL}, then method \code{'m1'} is automatically set. An
advantage of method \code{'m1'} is that it automatically sets up the factor
covariates for \code{\link[=plot_curves]{plot_curves()}} and \code{\link[=growthparameters]{growthparameters()}} functions. Note that
although method \code{'m1'} is preferred and is the default choice, it might
fail in some cases when model involves covariates particularly when model is
fit as \code{univariate_by}. In such cases, it is advised to switch to
method \code{'m2'}.}

\item{verbose}{An optional argument (logical, default \code{FALSE}) to
indicate whether to print information collected during setting up the
object(s).}

\item{usesavedfuns}{A logical (default \code{FALSE}) to indicate whether to
use the already exposed and saved \code{Stan} functions. This is for
internal use only during the testing of the functions and therefore should
not be used by users routinely because results might be unstable.}

\item{clearenvfuns}{A logical to indicate whether to clear the exposed
function from the environment (\code{TRUE}) or not (\code{FALSE}). If
\code{NULL} (default), then \code{clearenvfuns} is set as \code{TRUE} when
\code{usesavedfuns} is \code{TRUE}, and \code{FALSE} if \code{usesavedfuns}
is \code{FALSE}.}

\item{envir}{Environment used for function evaluation. The default is
\code{NULL} which will set \code{parent.frame()} as default environment.
Note that since most of post processing functions are based on \pkg{brms},
the elements needed for evaluation should be in the \code{.GlobalEnv}.
Therefore, it is strongly recommended to set \code{ envir = globalenv()}
(or \code{envir = .GlobalEnv}). This is particularly true for the
derivatives such as velocity curve.}

\item{...}{Additional arguments passed to the \code{\link[brms:conditional_effects.brmsfit]{brms::conditional_effects()}}
function. Please see \code{\link[brms:conditional_effects.brmsfit]{brms::conditional_effects()}} for details.}
}
\value{
An object of class 'brms_conditional_effects' which is a named list
with one data.frame per effect containing all information required to
generate conditional effects plots. See brms::conditional_effects for
details.
}
\description{
Display conditional effects of one or more numeric and/or categorical
predictors including two-way interaction effects.
}
\details{
The \strong{plot_conditional_effects()} is a wrapper around the
\code{\link[brms:conditional_effects.brmsfit]{brms::conditional_effects()}}. The \code{\link[brms:conditional_effects.brmsfit]{brms::conditional_effects()}} function
from the \pkg{brms} package can used to plot the fitted (distance) curve
when response (e.g., height) is not transformed. However, when the outcome
is log or square root transformed, the \code{\link[brms:conditional_effects.brmsfit]{brms::conditional_effects()}} will
return the fitted curve on the log or square root scale whereas the
\strong{plot_conditional_effects()} will return the fitted curve on the
original scale. Furthermore, the \strong{plot_conditional_effects()} also
plots the velocity curve on the original scale after making required
back-transformation. Apart from these differences, both these functions
(\link[brms:conditional_effects.brmsfit]{brms::conditional_effects} and \strong{plot_conditional_effects()} work
in the same manner. In other words, user can specify all the arguments
which are available in the \code{\link[brms:conditional_effects.brmsfit]{brms::conditional_effects()}}.
}
\examples{

# Fit Bayesian SITAR model 

# To avoid fitting the model which takes time, the model  
# fit has already been saved as 'berkeley_mfit.rda' file.
# See examples section of the main function for details on the model fit.

model <- berkeley_mfit

# Population average distance curve
plot_conditional_effects(model, deriv = 0, re_formula = NA)

\donttest{
# Individual-specific distance curves
plot_conditional_effects(model, deriv = 0, re_formula = NULL)

# Population average velocity curve
plot_conditional_effects(model, deriv = 1, re_formula = NA)

# Individual-specific velocity curves
plot_conditional_effects(model, deriv = 1, re_formula = NULL)
}

}
\seealso{
\code{\link[brms:conditional_effects.brmsfit]{brms::conditional_effects()}}
}
\author{
Satpal Sandhu  \email{satpal.sandhu@bristol.ac.uk}
}
