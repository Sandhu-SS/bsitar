% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fitted_draws.R
\name{fitted_draws.bgmfit}
\alias{fitted_draws.bgmfit}
\alias{fitted_draws}
\title{Fitted (expected) values from the posterior predictive distribution}
\usage{
\method{fitted_draws}{bgmfit}(
  model,
  newdata = NULL,
  resp = NULL,
  ndraws = NULL,
  re_formula = NULL,
  numeric_cov_at = NULL,
  levels_id = NULL,
  ipts = NULL,
  deriv = 0,
  deriv_model = TRUE,
  summary = TRUE,
  robust = FALSE,
  probs = c(0.025, 0.975),
  xrange = NULL,
  parms_eval = FALSE,
  parms_method = "getPeak",
  idata_method = "m1",
  verbose = FALSE,
  fullframe = NULL,
  dummy_to_factor = NULL,
  usesavedfuns = FALSE,
  clearenvfuns = NULL,
  envir = NULL,
  ...
)

fitted_draws(model, ...)
}
\arguments{
\item{model}{An object of class \code{bgmfit}.}

\item{newdata}{An optional data frame to be used in predictions. If
\code{NULL} (default), the model fit.}

\item{resp}{A character string to specify response variable when processing
posterior draws for the univariate-by-subgroup and multivariate models (see
\code{\link[=bsitar]{bsitar()}} for details on fitting univariate-by-subgroup and
multivariate models). For univariate model, \code{resp = NULL} (default).
Note that argument \code{resp} must be specified for the
univariate-by-subgroup and multivariate models otherwise it will result in
an error. On the other hand, argument \code{resp} must be \code{NULL} for
the univariate model. The default setting is \code{resp = NULL} assuming a
univariate model.}

\item{ndraws}{Positive integer indicating the number of posterior draws to be
used in estimation. If \code{NULL} (default), all draws are used.}

\item{re_formula}{Option to indicate whether or not to include the
individual/group-level effects in the estimation. When \code{NA} (default),
the individual-level effects are excluded and therefore population average
growth parameters are computed. When \code{NULL}, individual-level effects
are included in the computation and hence the growth parameters estimates
returned are individual-specific. In both situations, (i.e,, \code{NA} or
\code{NULL}), continuous and factor covariate(s) are appropriately included
in the estimation. The continuous covariates by default are set to their
means (see \code{numeric_cov_at} for details) whereas factor covariates are
left unaltered thereby allowing estimation of (factor) covariate specific
population average and individual-specific growth parameter at mean value
of continous covaristes(s).}

\item{numeric_cov_at}{An optional argument to specify the value of continuous
covariate(s). The default \code{NULL} option set the continuous
covariate(s) at their mean. Alternatively, a named list can be
supplied to manually set these values. For example, \code{numeric_cov_at =
  list(xx = 2)} will set the continuous covariate varibale 'xx' at 2. The
argument \code{numeric_cov_at} is ignored when no continuous covariate is
included in the model.}

\item{levels_id}{An optional argument to specify the \code{ids} for
hierarchical model (default \code{NULL}). It is used only when model is
applied to the data with 3 or more levels of hierarchy. For a two level
model, the \code{id} for second level is automatically inferred from the
model fit. Even for 3 or higher level model, ids are inferred from the
model fit but under the assumption that hierarchy is specified from
lower to upper levels i.e, \code{id} followed by \code{study} assuming that
\code{id} is nested within the \code{study} However, it is not guaranteed
that these ids are sorted correctly. Therefore, it is better to set them
manually.}

\item{ipts}{An integer to set the length of the predictor variable to get a
smooth velocity curve. The \code{NULL} will return original values whereas
an integer such as \code{ipts = 10} (default) will interpolate the
predictor. It is important to note that these interpolations do not alter
the range of predictor when calculating population average and/or the
individual specific growth curves.}

\item{deriv}{An integer to indicate whether to estimate distance curve or
derivatives (velocity and acceleration curves). Default \code{deriv = 0} is
for the distance curve, \code{deriv = 1} for velocity curve, and
\code{deriv = 2} for the acceleration curve.}

\item{deriv_model}{A logical (default \code{TRUE}) to indicate whether to
estimate model based derivatives or from the differentiation of the
distance curve. When model is fit with \code{decomp = 'QR'}, the only
approach available to estimate derivatives by the  differentiation of the
distance curve.}

\item{summary}{A logical (default \code{TRUE}) indicating whether only the
Estimate should be returned or Estimate along with SE and CI should be
computed. Setting this option to \code{FALSE} will reduce the computation
time but no SE or CI estimates will be available.}

\item{robust}{If \code{FALSE} (the default) the mean is used as the measure
of central tendency and the standard deviation as the measure of
variability. If \code{TRUE}, the median and the median absolute deviation
(MAD) are applied instead. Ignored if summary is \code{FALSE}.}

\item{probs}{The percentiles to be computed by the \code{quantile}
function. Only used if \code{summary} is \code{TRUE}.}

\item{xrange}{An integer to set the predictor range (i.e., age) when
executing the interpolation via \code{ipts}. The default \code{NULL} sets
the individual specific predictor range whereas code \code{xrange = 1} sets
same range for all individuals within the higher order grouping variable
(e.g., study). Code \code{xrange  = 2} sets the identical range across the
entire sample. Lastly, a paired numeric values can be supplied e.g.,
\code{xrange = c(6, 20)} to set the range between 6 and 20.}

\item{parms_eval}{A logical (default \code{FALSE}) to specify whether or not
to get growth parameters on the fly.}

\item{parms_method}{A character to specify the method used to when evaluating
\code{parms_eval}. The default is \code{getPeak} which uses the
\code{\link[sitar:getPeakTrough]{sitar::getPeak()}} function from the \code{sitar} package. The alternative
option is \code{findpeaks} that uses the \code{\link[pracma:findpeaks]{pracma::findpeaks()}} function
function from the \code{pracma} package. Note that the argument
\code{parms_method} is currently ignored.}

\item{idata_method}{A character string to indicate the interpolation method.
The number of of interpolation points is set up the \code{ipts} argument.
Options available for \code{idata_method} are \emph{method 1} (specified as
\code{'m1'}, default) and \emph{method 2} (specified as \code{'m2'}). The
\emph{method 1} (\code{'m1'}) is adapted from the the \pkg{iapvbs} package
and is documented here
\url{https://rdrr.io/github/Zhiqiangcao/iapvbs/src/R/exdata.R}
whereas \emph{method 2} (\code{'m2'}) is based on the \pkg{JMbayes}
package as documented here
\url{https://github.com/drizopoulos/JMbayes/blob/master/R/dynPred_lme.R}.
The \code{'m1'} method works by internally constructing the data frame based
on the model configuration whereas the method \code{'m2'} uses the exact
data frame used in model fit and can be accessed via \code{fit$data}. If
\code{idata_method = NULL}, then method \code{'m1'} is automatically set. An
advantage of method \code{'m1'} is that it automatically sets up the factor
covariates for \code{\link[=plot_curves]{plot_curves()}} and \code{\link[=growthparameters]{growthparameters()}} functions. Note that
although method \code{'m1'} is preferred and is the default choice, it might
fail in some cases when model involves covariates particularly when model is
fit as \code{univariate_by}. In such cases, it is advised to switch to
method \code{'m2'}.}

\item{verbose}{An optional argument (logical, default \code{FALSE}) to
indicate whether to print information collected during setting up the
object(s).}

\item{fullframe}{A logical to indicate whether to return \code{fullframe}
object in which \code{newdata} is bind to the summary estimates Note that
\code{fullframe} can not be combined with \code{summary = FALSE}.
Furthermore, \code{fullframe} can only be used when \code{idata_method =
  'm2'}. A particular use case is when fitting \code{univariate_by} model.
The \code{fullframe} is mainly for internal use only.}

\item{dummy_to_factor}{A named list (default \code{NULL}) that is used to
convert dummy variables into a factor variable. The named elements are
\code{factor.dummy}, \code{factor.name}, and \code{factor.level}. The
\code{factor.dummy} is a vector of character strings that will be converted
to a factor variable, and \code{factor.name} is a single character string
that is used to name the newly created factor variable. The
\code{factor.level} is used to name the levels of newly created factor.
When \code{factor.name} is \code{NULL}, then the factor name is internally
set as \code{factor.var}. If \code{factor.level} is \code{NULL}, then
names of factor levels are take from the \code{factor.dummy} i.e.,
the factor levels are assigned same name as \code{factor.dummy}. Note that
when \code{factor.level} is not \code{NULL}, its length must be same as
the length of the \code{factor.dummy}.}

\item{usesavedfuns}{A logical (default \code{FALSE}) to indicate whether to
use the already exposed and saved \code{Stan} functions. This is for
internal use only during the testing of the functions and therefore should
not be used by users routinely because results might be unstable.}

\item{clearenvfuns}{A logical to indicate whether to clear the exposed
function from the environment (\code{TRUE}) or not (\code{FALSE}). If
\code{NULL} (default), then \code{clearenvfuns} is set as \code{TRUE} when
\code{usesavedfuns} is \code{TRUE}, and \code{FALSE} if \code{usesavedfuns}
is \code{FALSE}.}

\item{envir}{Environment used for function evaluation. The default is
\code{NULL} which will set \code{parent.frame()} as default environment.
Note that since most of post processing functions are based on \pkg{brms},
the elements needed for evaluation should be in the \code{.GlobalEnv}.
Therefore, it is strongly recommended to set \code{ envir = globalenv()}
(or \code{envir = .GlobalEnv}). This is particularly true for the
derivatives such as velocity curve.}

\item{...}{Additional arguments passed to the \code{\link[brms:fitted.brmsfit]{brms::fitted.brmsfit()}}
function. Please see \code{brms::fitted.brmsfit()} for details on
various options available.}
}
\value{
An array of predicted mean response values. See \link[brms:fitted.brmsfit]{brms::fitted.brmsfit}
for details.
}
\description{
The \strong{fitted_draws()} is a wrapper around the
\code{\link[brms:fitted.brmsfit]{brms::fitted.brmsfit()}} function to obtain fitted values (and their
summary) from the posterior draws. See \code{\link[brms:fitted.brmsfit]{brms::fitted.brmsfit()}} for
details.
}
\details{
The \strong{fitted_draws()} computes the fitted values from the
posterior draws. The \code{\link[brms:fitted.brmsfit]{brms::fitted.brmsfit()}} function from the \pkg{brms}
package can used to get the fitted (distance) values when outcome (e.g.,
height) is untransformed. However, when the outcome is log or square root
transformed, the \code{\link[brms:fitted.brmsfit]{brms::fitted.brmsfit()}} function will return the fitted
curve on the log or square root scale whereas the \strong{fitted_draws()}
function returns the fitted values on the original scale. Furthermore, the
\strong{fitted_draws()} also compute the first derivative of (velocity)
that too on the original scale after making required back-transformation.
Except for these differences, both these functions (i.e.,
\code{\link[brms:fitted.brmsfit]{brms::fitted.brmsfit()}} and \code{\link[=fitted_draws]{fitted_draws()}}) work in the same manner. In
other words, user can specify all the options available in the
\code{\link[brms:fitted.brmsfit]{brms::fitted.brmsfit()}}.
}
\examples{

# Fit Bayesian SITAR model 

# To avoid fitting the model which takes time, the model  
# fit has already been saved as 'berkeley_mfit.rda' file.
# See examples section of the main function for details on the model fit.

model <- berkeley_mfit

# Population average distance curve
fitted_draws(model, deriv = 0, re_formula = NA)

\donttest{
# Individual-specific distance curves
fitted_draws(model, deriv = 0, re_formula = NULL)

# Population average velocity curve
fitted_draws(model, deriv = 1, re_formula = NA)

# Individual-specific velocity curves
fitted_draws(model, deriv = 1, re_formula = NULL)
}

}
\seealso{
\code{\link[brms:fitted.brmsfit]{brms::fitted.brmsfit()}}
}
\author{
Satpal Sandhu  \email{satpal.sandhu@bristol.ac.uk}
}
