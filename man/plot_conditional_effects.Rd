% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plot_conditional_effects.R
\name{plot_conditional_effects.bgmfit}
\alias{plot_conditional_effects.bgmfit}
\alias{plot_conditional_effects}
\title{Visualize conditional effects for the Bayesian SITAR model}
\usage{
\method{plot_conditional_effects}{bgmfit}(
  model,
  effects = NULL,
  conditions = NULL,
  int_conditions = NULL,
  re_formula = NA,
  spaghetti = FALSE,
  surface = FALSE,
  categorical = FALSE,
  ordinal = FALSE,
  method = NULL,
  allow_new_levels = FALSE,
  estimation_method = "fitted",
  transform = NULL,
  transform_draws = NULL,
  resolution = 100,
  select_points = 0,
  too_far = 0,
  probs = c(0.025, 0.975),
  robust = TRUE,
  newdata = NULL,
  ndraws = NULL,
  dpar = NULL,
  draw_ids = NULL,
  levels_id = NULL,
  resp = NULL,
  ipts = NULL,
  deriv = 0,
  summary = FALSE,
  model_deriv = NULL,
  idata_method = NULL,
  verbose = FALSE,
  label.x = NULL,
  label.y = NULL,
  label.title = NULL,
  label.subtitle = NULL,
  legendpos = NULL,
  dummy_to_factor = NULL,
  expose_function = FALSE,
  usesavedfuns = NULL,
  clearenvfuns = NULL,
  funlist = NULL,
  xvar = NULL,
  difx = NULL,
  idvar = NULL,
  itransform = NULL,
  newdata_fixed = NULL,
  envir = NULL,
  ...
)

plot_conditional_effects(model, ...)
}
\arguments{
\item{model}{An object of class \code{bgmfit}.}

\item{effects}{An optional character vector naming effects (main effects or
interactions) for which to compute conditional plots. Interactions are
specified by a \code{:} between variable names. If \code{NULL} (the
default), plots are generated for all main effects and two-way interactions
estimated in the model. When specifying \code{effects} manually, \emph{all}
two-way interactions (including grouping variables) may be plotted
even if not originally modeled.}

\item{conditions}{An optional \code{data.frame} containing variable values
to condition on. Each effect defined in \code{effects} will
be plotted separately for each row of \code{conditions}. Values in the
\code{cond__} column will be used as titles of the subplots. If \code{cond__}
is not given, the row names will be used for this purpose instead.
It is recommended to only define a few rows in order to keep the plots clear.
See \code{\link[brms]{make_conditions}} for an easy way to define conditions.
If \code{NULL} (the default), numeric variables will be conditionalized by
using their means and factors will get their first level assigned.
\code{NA} values within factors are interpreted as if all dummy
variables of this factor are zero. This allows, for instance, to make
predictions of the grand mean when using sum coding.}

\item{int_conditions}{An optional named \code{list} whose elements are
vectors of values of the variables specified in \code{effects}.
At these values, predictions are evaluated. The names of
\code{int_conditions} have to match the variable names exactly.
Additionally, the elements of the vectors may be named themselves,
in which case their names appear as labels for the conditions in the plots.
Instead of vectors, functions returning vectors may be passed and are
applied on the original values of the corresponding variable.
If \code{NULL} (the default), predictions are evaluated at the
\eqn{mean} and at \eqn{mean +/- sd} for numeric predictors and at
all categories for factor-like predictors.}

\item{re_formula}{A formula containing group-level effects to be considered
in the conditional predictions. If \code{NULL}, include all group-level
effects; if \code{NA} (default), include no group-level effects.}

\item{spaghetti}{Logical. Indicates if predictions should
be visualized via spaghetti plots. Only applied for numeric
predictors. If \code{TRUE}, it is recommended
to set argument \code{ndraws} to a relatively small value
(e.g., \code{100}) in order to reduce computation time.}

\item{surface}{Logical. Indicates if interactions or
two-dimensional smooths should be visualized as a surface.
Defaults to \code{FALSE}. The surface type can be controlled
via argument \code{stype} of the related plotting method.}

\item{categorical}{Logical. Indicates if effects of categorical
or ordinal models should be shown in terms of probabilities
of response categories. Defaults to \code{FALSE}.}

\item{ordinal}{(Deprecated) Please use argument \code{categorical}.
Logical. Indicates if effects in ordinal models
should be visualized as a raster with the response categories
on the y-axis. Defaults to \code{FALSE}.}

\item{method}{Method used to obtain predictions. Can be set to
\code{"posterior_epred"} (the default), \code{"posterior_predict"},
or \code{"posterior_linpred"}. For more details, see the respective
function documentations.}

\item{allow_new_levels}{A flag indicating if new levels of group-level
effects are allowed (defaults to \code{FALSE}). Only relevant if
\code{newdata} is provided.}

\item{estimation_method}{A character string specifying the estimation method
when calculating the velocity from the posterior draws. The \code{'fitted'}
method internally calls \code{\link[=fitted_draws]{fitted_draws()}}, while the
\code{'predict'} method calls \code{\link[=predict_draws]{predict_draws()}}. See
\code{\link[brms:fitted.brmsfit]{brms::fitted.brmsfit()}} and \code{\link[brms:predict.brmsfit]{brms::predict.brmsfit()}} for details.}

\item{transform}{A function or a character string naming
a function to be applied on the predicted responses
before summary statistics are computed. Only allowed
if \code{method = "posterior_predict"}.}

\item{transform_draws}{A function applied to individual draws from the
posterior distribution before computing summaries (default \code{NULL}).
The argument \code{transform_draws} is derived from the
\code{\link[marginaleffects:predictions]{marginaleffects::predictions()}} function and should not be confused with
the \code{transform} argument from the deprecated
\code{\link[brms:posterior_predict.brmsfit]{brms::posterior_predict()}} function. It's important to note that for both
\code{\link[marginaleffects:predictions]{marginaleffects::predictions()}} and \code{\link[marginaleffects:predictions]{marginaleffects::avg_predictions()}},
the \code{transform_draws} argument takes precedence over the
\code{transform} argument. Note that when \code{transform_draws = NULL}, an
attempt is made to automatically set \code{transform_draws = 'exp'} for
\code{dpar = 'sigma'}. User can set  \code{transform_draws = FALSE} to turn
off this automatic assignment of \code{'exp'} to the
\code{transform_draws}. It is also important to set \code{transform_draws =
  FALSE} when computing the first derivative (velocity) for \code{dpar =
  'sigma'}.}

\item{resolution}{Number of support points used to generate
the plots. Higher resolution leads to smoother plots.
Defaults to \code{100}. If \code{surface} is \code{TRUE},
this implies \code{10000} support points for interaction terms,
so it might be necessary to reduce \code{resolution}
when only few RAM is available.}

\item{select_points}{Positive number.
Only relevant if \code{points} or \code{rug} are set to \code{TRUE}:
Actual data points of numeric variables that
are too far away from the values specified in \code{conditions}
can be excluded from the plot. Values are scaled into
the unit interval and then points more than \code{select_points}
from the values in \code{conditions} are excluded.
By default, all points are used.}

\item{too_far}{Positive number.
For surface plots only: Grid points that are too
far away from the actual data points can be excluded from the plot.
\code{too_far} determines what is too far. The grid is scaled into
the unit square and then grid points more than \code{too_far}
from the predictor variables are excluded. By default, all
grid points are used. Ignored for non-surface plots.}

\item{probs}{(Deprecated) The quantiles to be used in the computation of
uncertainty intervals. Please use argument \code{prob} instead.}

\item{robust}{If \code{TRUE} (the default) the median is used as the
measure of central tendency. If \code{FALSE} the mean is used instead.}

\item{newdata}{An optional data frame for estimation. If \code{NULL}
(default), \code{newdata} is retrieved from the \code{model}.}

\item{ndraws}{A positive integer indicating the number of posterior draws to
use in estimation. If \code{NULL} (default), all draws are used.}

\item{dpar}{Optional name of a predicted distributional parameter.
If specified, expected predictions of this parameters are returned.}

\item{draw_ids}{An integer specifying the specific posterior draw(s) to use
in estimation (default \code{NULL}).}

\item{levels_id}{An optional argument to specify the \code{ids} for the
hierarchical model (default \code{NULL}). It is used only when the model is
applied to data with three or more levels of hierarchy. For a two-level
model, \code{levels_id} is automatically inferred from the model fit. For
models with three or more levels, \code{levels_id} is inferred from the
model fit under the assumption that hierarchy is specified from the lowest
to the uppermost level, i.e., \code{id} followed by \code{study}, where
\code{id} is nested within \code{study}. However, it is not guaranteed that
\code{levels_id} is sorted correctly, so it is better to set it manually
when fitting a model with three or more levels of hierarchy.}

\item{resp}{A character string (default \code{NULL}) to specify the response
variable when processing posterior draws for \code{univariate_by} and
\code{multivariate} models. See \code{\link[=bsitar]{bsitar()}} for details on
\code{univariate_by} and \code{multivariate} models.}

\item{ipts}{An integer specifying the number of points for interpolating the
predictor variable (e.g., age) to generate smooth curves for predictions
and plots. This value is used as the \code{length.out} argument for
\code{\link[=seq]{seq()}}, controlling the smoothness of distance and velocity curves without
altering the predictor range.
\describe{
\item{\code{NULL} (the default)}{Engages automatic behavior based on the
\code{dpar} argument: it is internally set to \code{50} for the mean
response (\code{dpar = 'mu'}), ensuring smooth curves, while for the
distributional parameters (e.g., \code{dpar = 'sigma'}), no
interpolation is performed.}
\item{An integer (e.g., \code{100})}{Explicitly sets the number of
interpolation points.}
\item{\code{FALSE}}{Disables all interpolation, forcing predictions to
be made only at the original data points of the predictor variable.}
}

This argument affects the following post-processing functions: \cr
\code{\link[=fitted_draws]{fitted_draws()}}, \code{\link[=predict_draws]{predict_draws()}}, \code{\link[=growthparameters]{growthparameters()}}, \code{\link[=plot_curves]{plot_curves()}},
\code{\link[=marginal_draws]{marginal_draws()}}, \code{\link[=marginal_comparisons]{marginal_comparisons()}}, and
\code{\link[=marginal_growthparameters]{marginal_growthparameters()}}.}

\item{deriv}{An integer indicating whether to estimate the distance curve or
its derivative (velocity curve). The default \code{deriv = 0} is for the
distance curve, while \code{deriv = 1} is for the velocity curve.}

\item{summary}{A logical value indicating whether only the estimate should be
computed (\code{TRUE}), or whether the estimate along with SE and CI should
be returned (\code{FALSE}, default). Setting \code{summary} to \code{FALSE}
will increase computation time. Note that \code{summary = FALSE} is
required to obtain correct estimates when \code{re_formula = NULL}.}

\item{model_deriv}{A logical value specifying whether to estimate the
velocity curve from the derivative function or by differentiating the
distance curve. Set \code{model_deriv = TRUE} for functions that require
the velocity curve, such as \code{growthparameters()} and
\code{plot_curves()}. Set it to \code{NULL} for functions that use the
distance curve (i.e., fitted values), such as \code{loo_validation()} and
\code{plot_ppc()}.}

\item{idata_method}{A character string to indicate the interpolation method.
The number of interpolation points is set by the \code{ipts} argument.
Available options for \code{idata_method} are \emph{method 1} (specified as
\code{'m1'}) and \emph{method 2} (specified as \code{'m2'}).
\itemize{
\item \emph{Method 1} (\code{'m1'}) is adapted from the \pkg{iapvbs} package
and is documented
\href{https://rdrr.io/github/Zhiqiangcao/iapvbs/src/R/exdata.R}{here}.
\item \emph{Method 2} (\code{'m2'}) is based on the \pkg{JMbayes} package
and is documented
\href{https://github.com/drizopoulos/JMbayes/blob/master/R/dynPred_lme.R}{here}.
The \code{'m1'} method works by internally constructing the data frame
based on the model configuration, while the \code{'m2'} method uses the
exact data frame from the model fit, accessible via \code{fit$data}. If
\code{idata_method = NULL} (default), method \code{'m2'} is automatically
selected. Note that method \code{'m1'} may fail in certain cases,
especially when the model includes covariates (particularly in
\code{univariate_by} models). In such cases, it is recommended to use
method \code{'m2'}.
}}

\item{verbose}{A logical argument (default \code{FALSE}) to specify whether
to print information collected during the setup of the object(s).}

\item{label.x}{An optional character string to label the x-axis. If
\code{NULL} (default), the x-axis label will be taken from the predictor
(e.g., age).}

\item{label.y}{An optional character string to label the y-axis. If
\code{NULL} (default), the y-axis label will be taken from the plot type
(e.g., distance, velocity). When \code{layout = 'facet'}, the label is
removed, and the same label is used as the title.}

\item{label.title}{An optional character string to label the title. Default
\code{NULL}.}

\item{label.subtitle}{An optional character string to label the title. Default
\code{NULL}}

\item{legendpos}{A character string to specify the position of the legend. If
\code{NULL} (default), the legend position is set to 'bottom' for distance
and velocity curves in the \code{'single'} layout. For individual-specific
curves, the legend position is set to \code{'none'} to suppress the legend.}

\item{dummy_to_factor}{A named list (default \code{NULL}) to convert dummy
variables into a factor variable. The list must include the following
elements:
\itemize{
\item \code{factor.dummy}: A character vector of dummy variables to be
converted to factors.
\item \code{factor.name}: The name for the newly created factor variable
(default is \code{'factor.var'} if \code{NULL}).
\item \code{factor.level}: A vector specifying the factor levels.
If \code{NULL}, levels are taken from \code{factor.dummy}.
If \code{factor.level} is provided, its length must match
\code{factor.dummy}.
}}

\item{expose_function}{A logical argument (default \code{FALSE}) to indicate
whether Stan functions should be exposed. If \code{TRUE}, any Stan
functions exposed during the model fit using \code{expose_function = TRUE}
in the \code{\link[=bsitar]{bsitar()}} function are saved and can be used in post-processing. By
default, \code{expose_function = FALSE} in post-processing functions,
except in \code{\link[=optimize_model]{optimize_model()}} where it is set to \code{NULL}. If
\code{NULL}, the setting is inherited from the original model fit. It must
be set to \code{TRUE} when adding \code{fit criteria} or \code{bayes_R2}
during model optimization.}

\item{usesavedfuns}{A logical value (default \code{NULL}) indicating whether
to use already exposed and saved Stan functions. This is typically set
automatically based on the \code{expose_functions} argument from the
\code{\link[=bsitar]{bsitar()}} call. Manual specification of \code{usesavedfuns} is rarely
needed and is intended for internal testing, as improper use can lead to
unreliable estimates.}

\item{clearenvfuns}{A logical value indicating whether to clear the exposed
Stan functions from the environment (\code{TRUE}) or not (\code{FALSE}). If
\code{NULL}, \code{clearenvfuns} is set based on the value of
\code{usesavedfuns}: \code{TRUE} if \code{usesavedfuns = TRUE}, or
\code{FALSE} if \code{usesavedfuns = FALSE}.}

\item{funlist}{A list (default \code{NULL}) specifying function names. This
is rarely needed, as required functions are typically retrieved
automatically. A use case for \code{funlist} is when \code{sigma_formula},
\code{sigma_formula_gr}, or \code{sigma_formula_gr_str} use an external
function (e.g., \code{poly(age)}). The \code{funlist} should include
function names defined in the \code{globalenv()}. For functions needing
both distance and velocity curves (e.g., \code{plot_curves(..., opt =
  'dv')}), \code{funlist} must include two functions: one for the distance
curve and one for the velocity curve.}

\item{xvar}{A character string (default \code{NULL}) specifying the
\code{'x'} variable. Rarely used because \code{xvar} is inferred
internally. A use case is when conflicting variables exist (e.g.,
\code{sigma_formula}) and user wants to set a specific variable as
\code{'x'}.}

\item{difx}{A character string (default \code{NULL}) specifying the
\code{'x'} variable that should be used for manual differentiation of the
distance curve. Internally, the \code{xvar} is set as \code{difx} if
specified. The argument \code{difx} is evaluated only when \code{dpar =
  'sigma'}, ignored otherwise. Note that argument \code{xvar} itself is rarely
used because \code{xvar} is inferred internally. A use case is when
conflicting variables exist (e.g., \code{sigma_formula}) and user wants to
set a specific variable as \code{'x'}.}

\item{idvar}{A character string (default \code{NULL}) specifying the
\code{'id'} variable. Rarely used because \code{idvar} is inferred
internally.}

\item{itransform}{A character string (default \code{NULL}) indicating the
variables names that are reverse transformed. Options are  \code{c("x",
  "y", "sigma")}. The \code{itransform} is primarily used to get the
\code{xvar} variable at original scale i.e., \code{itransform = 'x'}. To
turn of all transformations, use \code{itransform = ""}. when
\code{itransform = NULL}, the appropriate transformation for \code{xvar} is
selected automatically. Note that when no match for \code{xvar} is found in
the \code{data,frame}, the \code{itransform} will be ignored within the
calling function, \code{'prepare_transformations()'}.}

\item{newdata_fixed}{An indicator to specify whether to check data
format and structure for the user provided \code{newdata}, and apply needed
\code{prepare_data2} and \code{prepare_transformations}
(\code{newdata_fixed = NULL}, default), return user provided \code{newdata}
(\code{newdata = TRUE}) as it is without checking for the data format or
applying \code{prepare_data2} and \code{prepare_transformations}
(\code{newdata_fixed = 0}), check for the data format and if needed,
prepare data format using \code{prepare_data2} (\code{newdata_fixed = 1}),
or apply \code{prepare_transformations} only assuming that data format is
correct (\code{newdata_fixed = 2}). It is strongly recommended that user
either leave the \code{newdata = NULL} and \code{newdata_fixed = NULL} in
which case data used in the model fitting is automatically retrieved and
checked for the required data format and transformations, and if needed,
\code{prepare_data2} and \code{prepare_transformations} are applied
internally. The other flags provided for  \code{newdata_fixed = 0, 1, 2}
are mainly for the internal use during post-processing.}

\item{envir}{The environment used for function evaluation. The default is
\code{NULL}, which sets the environment to \code{parent.frame()}. Since
most post-processing functions rely on \pkg{brms}, it is recommended to set
\code{envir = globalenv()} or \code{envir = .GlobalEnv}, especially for
derivatives like velocity curves.}

\item{...}{Additional arguments passed to the \code{\link[brms:conditional_effects.brmsfit]{brms::conditional_effects()}}
function. Please see \code{\link[brms:conditional_effects.brmsfit]{brms::conditional_effects()}} for details.}
}
\value{
An object of class \code{'brms_conditional_effects'}, which is a
named list with one data.frame per effect containing all information
required to generate conditional effects plots. See
\code{\link[brms:conditional_effects.brmsfit]{brms::conditional_effects()}} for details.
}
\description{
Display conditional effects of one or more numeric and/or categorical
predictors including two-way interaction effects.
}
\details{
The \strong{plot_conditional_effects()} is a wrapper around the
\code{\link[brms:conditional_effects.brmsfit]{brms::conditional_effects()}}. The \code{\link[brms:conditional_effects.brmsfit]{brms::conditional_effects()}} function
from the \pkg{brms} package can be used to plot the fitted (distance) curve
when response (e.g., height) is not transformed. However, when the outcome
is log or square root transformed, the \code{\link[brms:conditional_effects.brmsfit]{brms::conditional_effects()}} will
return the fitted curve on the log or square root scale, whereas the
\strong{plot_conditional_effects()} will return the fitted curve on the
original scale. Furthermore, the \strong{plot_conditional_effects()} also
plots the velocity curve on the original scale after making the required
back-transformation. Apart from these differences, both these functions
(\link[brms:conditional_effects.brmsfit]{brms::conditional_effects} and \strong{plot_conditional_effects()}) work
in the same manner. In other words, the user can specify all the arguments
which are available in the \code{\link[brms:conditional_effects.brmsfit]{brms::conditional_effects()}}. An alternative
approach is to \code{\link[=marginal_draws]{marginal_draws()}} function (with \code{plot = TRUE}) which
is based on the \pkg{marginaleffects}.
}
\examples{
\donttest{
# Fit Bayesian SITAR model 

# To avoid mode estimation which takes time, the Bayesian SITAR model fit to 
# the 'berkeley_exdata' has been saved as an example fit ('berkeley_exfit').
# See 'bsitar' function for details on 'berkeley_exdata' and 'berkeley_exfit'.

# Check and confirm whether model fit object 'berkeley_exfit' exists
 berkeley_exfit <- getNsObject(berkeley_exfit)

model <- berkeley_exfit

# Population average distance curve
plot_conditional_effects(model, deriv = 0, re_formula = NA)

# Individual-specific distance curves
plot_conditional_effects(model, deriv = 0, re_formula = NULL)

# Population average velocity curve
plot_conditional_effects(model, deriv = 1, re_formula = NA)

# Individual-specific velocity curves
plot_conditional_effects(model, deriv = 1, re_formula = NULL)
}

}
\seealso{
\code{\link[brms:conditional_effects.brmsfit]{brms::conditional_effects()}}
}
\author{
Satpal Sandhu  \email{satpal.sandhu@bristol.ac.uk}
}
