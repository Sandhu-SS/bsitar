% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fitted_draws.R
\name{fitted_draws.bgmfit}
\alias{fitted_draws.bgmfit}
\alias{fitted_draws}
\title{Estimate fitted (Expected) values for the Bayesian SITAR model}
\usage{
\method{fitted_draws}{bgmfit}(
  model,
  newdata = NULL,
  resp = NULL,
  dpar = NULL,
  ndraws = NULL,
  draw_ids = NULL,
  re_formula = NA,
  allow_new_levels = FALSE,
  sample_new_levels = "uncertainty",
  incl_autocor = TRUE,
  numeric_cov_at = NULL,
  levels_id = NULL,
  avg_reffects = NULL,
  aux_variables = NULL,
  grid_add = NULL,
  ipts = NULL,
  deriv = 0,
  model_deriv = TRUE,
  summary = TRUE,
  robust = FALSE,
  transform_draws = NULL,
  scale = c("response", "linear"),
  probs = c(0.025, 0.975),
  xrange = NULL,
  xrange_search = NULL,
  parms_eval = FALSE,
  parms_method = "getPeak",
  idata_method = NULL,
  verbose = FALSE,
  fullframe = NULL,
  dummy_to_factor = NULL,
  expose_function = FALSE,
  usesavedfuns = NULL,
  clearenvfuns = NULL,
  funlist = NULL,
  xvar = NULL,
  difx = NULL,
  idvar = NULL,
  itransform = NULL,
  newdata_fixed = NULL,
  envir = NULL,
  ...
)

fitted_draws(model, ...)
}
\arguments{
\item{model}{An object of class \code{bgmfit}.}

\item{newdata}{An optional data frame for estimation. If \code{NULL}
(default), \code{newdata} is retrieved from the \code{model}.}

\item{resp}{A character string (default \code{NULL}) to specify the response
variable when processing posterior draws for \code{univariate_by} and
\code{multivariate} models. See \code{\link[=bsitar]{bsitar()}} for details on
\code{univariate_by} and \code{multivariate} models.}

\item{dpar}{Optional name of a predicted distributional parameter.
If specified, expected predictions of this parameters are returned.}

\item{ndraws}{A positive integer indicating the number of posterior draws to
use in estimation. If \code{NULL} (default), all draws are used.}

\item{draw_ids}{An integer specifying the specific posterior draw(s) to use
in estimation (default \code{NULL}).}

\item{re_formula}{Option to indicate whether or not to include
individual/group-level effects in the estimation. When \code{NA} (default),
individual-level effects are excluded, and population average growth
parameters are computed. When \code{NULL}, individual-level effects are
included in the computation, and the resulting growth parameters are
individual-specific. In both cases (\code{NA} or \code{NULL}), continuous
and factor covariates are appropriately included in the estimation.
Continuous covariates are set to their means by default (see
\code{numeric_cov_at} for details), while factor covariates remain
unaltered, allowing for the estimation of covariate-specific population
average and individual-specific growth parameters.}

\item{allow_new_levels}{A flag indicating if new levels of group-level
effects are allowed (defaults to \code{FALSE}). Only relevant if
\code{newdata} is provided.}

\item{sample_new_levels}{Indicates how to sample new levels for grouping
factors specified in \code{re_formula}. This argument is only relevant if
\code{newdata} is provided and \code{allow_new_levels} is set to
\code{TRUE}. If \code{"uncertainty"} (default), each posterior sample for a
new level is drawn from the posterior draws of a randomly chosen existing
level. Each posterior sample for a new level may be drawn from a different
existing level such that the resulting set of new posterior draws
represents the variation across existing levels. If \code{"gaussian"},
sample new levels from the (multivariate) normal distribution implied by the
group-level standard deviations and correlations. This options may be useful
for conducting Bayesian power analysis or predicting new levels in
situations where relatively few levels where observed in the old_data. If
\code{"old_levels"}, directly sample new levels from the existing levels,
where a new level is assigned all of the posterior draws of the same
(randomly chosen) existing level.}

\item{incl_autocor}{A flag indicating if correlation structures originally
specified via \code{autocor} should be included in the predictions.
Defaults to \code{TRUE}.}

\item{numeric_cov_at}{An optional (named list) argument to specify the value
of continuous covariate(s). The default \code{NULL} option sets the
continuous covariate(s) to their mean. Alternatively, a named list can be
supplied to manually set these values. For example, \code{numeric_cov_at =
  list(xx = 2)} will set the continuous covariate variable 'xx' to 2. The
argument \code{numeric_cov_at} is ignored when no continuous covariates are
included in the model.}

\item{levels_id}{An optional argument to specify the \code{ids} for the
hierarchical model (default \code{NULL}). It is used only when the model is
applied to data with three or more levels of hierarchy. For a two-level
model, \code{levels_id} is automatically inferred from the model fit. For
models with three or more levels, \code{levels_id} is inferred from the
model fit under the assumption that hierarchy is specified from the lowest
to the uppermost level, i.e., \code{id} followed by \code{study}, where
\code{id} is nested within \code{study}. However, it is not guaranteed that
\code{levels_id} is sorted correctly, so it is better to set it manually
when fitting a model with three or more levels of hierarchy.}

\item{avg_reffects}{An optional argument (default \code{NULL}) to calculate
(marginal/average) curves and growth parameters, such as APGV and PGV. If
specified, it must be a named list indicating the \code{over} (typically a
level 1 predictor, such as age), \code{feby} (fixed effects, typically a
factor variable), and \code{reby} (typically \code{NULL}, indicating that
parameters are integrated over the random effects). For example,
\code{avg_reffects = list(feby = 'study', reby = NULL, over = 'age')}.}

\item{aux_variables}{An optional argument to specify the variable(s) that can
be passed to the \code{ipts} argument (see below). This is useful when
fitting location-scale models and measurement error models. If
post-processing functions throw an error such as \code{variable 'x' not
  found in either 'data' or 'data2'}, consider using \code{aux_variables}.}

\item{grid_add}{An optional argument to specify the variable(s) that can be
passed to the \code{\link[marginaleffects:datagrid]{marginaleffects::datagrid()}}. This is useful when fitting
location-scale models and measurement error models. If
post-processing functions throw an error such as \code{variable 'x' not
  found in either 'data' or 'data2'}, consider using \code{grid_add}.
Note that unlike \code{aux_variables} which are passed to the internal data
functions such as \code{'get.newdata'}, the \code{grid_add} are passed to
the \code{\link[marginaleffects:datagrid]{marginaleffects::datagrid()}}.}

\item{ipts}{An integer specifying the number of points for interpolating the
predictor variable (e.g., age) to generate smooth curves for predictions
and plots. This value is used as the \code{length.out} argument for
\code{\link[=seq]{seq()}}, controlling the smoothness of distance and velocity curves without
altering the predictor range.
\describe{
\item{\code{NULL} (the default)}{Engages automatic behavior based on the
\code{dpar} argument: it is internally set to \code{50} for the mean
response (\code{dpar = 'mu'}), ensuring smooth curves, while for the
distributional parameters (e.g., \code{dpar = 'sigma'}), no
interpolation is performed.}
\item{An integer (e.g., \code{100})}{Explicitly sets the number of
interpolation points.}
\item{\code{FALSE}}{Disables all interpolation, forcing predictions to
be made only at the original data points of the predictor variable.}
}

This argument affects the following post-processing functions: \cr
\code{\link[=fitted_draws]{fitted_draws()}}, \code{\link[=predict_draws]{predict_draws()}}, \code{\link[=growthparameters]{growthparameters()}}, \code{\link[=plot_curves]{plot_curves()}},
\code{\link[=marginal_draws]{marginal_draws()}}, \code{\link[=marginal_comparisons]{marginal_comparisons()}}, and
\code{\link[=marginal_growthparameters]{marginal_growthparameters()}}.}

\item{deriv}{An integer indicating whether to estimate the distance curve or
its derivative (velocity curve). The default \code{deriv = 0} is for the
distance curve, while \code{deriv = 1} is for the velocity curve.}

\item{model_deriv}{A logical value specifying whether to estimate the
velocity curve from the derivative function or by differentiating the
distance curve. Set \code{model_deriv = TRUE} for functions that require
the velocity curve, such as \code{growthparameters()} and
\code{plot_curves()}. Set it to \code{NULL} for functions that use the
distance curve (i.e., fitted values), such as \code{loo_validation()} and
\code{plot_ppc()}.}

\item{summary}{A logical value indicating whether only the estimate should be
computed (\code{TRUE}), or whether the estimate along with SE and CI should
be returned (\code{FALSE}, default). Setting \code{summary} to \code{FALSE}
will increase computation time. Note that \code{summary = FALSE} is
required to obtain correct estimates when \code{re_formula = NULL}.}

\item{robust}{A logical value to specify the summary options. If \code{FALSE}
(default), the mean is used as the measure of central tendency and the
standard deviation as the measure of variability. If \code{TRUE}, the
median and median absolute deviation (MAD) are applied instead. Ignored if
\code{summary} is \code{FALSE}.}

\item{transform_draws}{A function applied to individual draws from the
posterior distribution before computing summaries (default \code{NULL}).
The argument \code{transform_draws} is derived from the
\code{\link[marginaleffects:predictions]{marginaleffects::predictions()}} function and should not be confused with
the \code{transform} argument from the deprecated
\code{\link[brms:posterior_predict.brmsfit]{brms::posterior_predict()}} function. It's important to note that for both
\code{\link[marginaleffects:predictions]{marginaleffects::predictions()}} and \code{\link[marginaleffects:predictions]{marginaleffects::avg_predictions()}},
the \code{transform_draws} argument takes precedence over the
\code{transform} argument. Note that when \code{transform_draws = NULL}, an
attempt is made to automatically set \code{transform_draws = 'exp'} for
\code{dpar = 'sigma'}. User can set  \code{transform_draws = FALSE} to turn
off this automatic assignment of \code{'exp'} to the
\code{transform_draws}. It is also important to set \code{transform_draws =
  FALSE} when computing the first derivative (velocity) for \code{dpar =
  'sigma'}.}

\item{scale}{Either \code{"response"} or \code{"linear"}.
If \code{"response"}, results are returned on the scale
of the response variable. If \code{"linear"},
results are returned on the scale of the linear predictor term,
that is without applying the inverse link function or
other transformations.}

\item{probs}{The percentiles to be computed by the \code{quantile}
function. Only used if \code{summary} is \code{TRUE}.}

\item{xrange}{An integer to set the predictor range (e.g., age) when
executing the interpolation via \code{ipts}. By default, \code{NULL} sets
the individual-specific predictor range. Setting \code{xrange = 1} applies
the same range for individuals within the same higher grouping variable
(e.g., study). Setting \code{xrange = 2} applies an identical range across
the entire sample. Alternatively, a numeric vector (e.g., \code{xrange =
  c(6, 20)}) can be provided to set the range within the specified values.}

\item{xrange_search}{A vector of length two or a character string
\code{'range'} to set the range of the predictor variable (\code{x}) within
which growth parameters are searched. This is useful when there is more
than one peak and the user wants to summarize the peak within a specified
range of the \code{x} variable. The default value is \code{xrange_search =
  NULL}.}

\item{parms_eval}{A logical value to specify whether or not to compute growth
parameters on the fly. This is for internal use only and is mainly needed
for compatibility across internal functions.}

\item{parms_method}{A character string specifying the method used when
evaluating \code{parms_eval}. The default method is \code{getPeak}, which
uses the \code{\link[sitar:getPeakTrough]{sitar::getPeak()}} function from the \code{sitar} package.
Alternatively, \code{findpeaks} uses the \code{findpeaks} function from the
\code{pracma} package. This parameter is for internal use and ensures
compatibility across internal functions.}

\item{idata_method}{A character string specifying the interpolation method
(default \code{NULL}). The number of interpolation points is controlled by
the \code{ipts} argument.

Available options:
\itemize{
\item \code{'m1'}: Adapted from the \pkg{iapvbs} package (documented
\href{https://rdrr.io/github/Zhiqiangcao/iapvbs/src/R/exdata.R}{here}). This
method internally constructs the data frame based on the model
configuration. \emph{Note:} This method may fail if the model includes
covariates (especially in \code{univariate_by} models).
\item \code{'m2'}: Based on the \pkg{JMbayes} package (documented
\href{https://github.com/drizopoulos/JMbayes/blob/master/R/dynPred_lme.R}{here}).
This method uses the exact data frame from the model fit
(\code{fit$data}) and is generally more robust.
}

If \code{idata_method = NULL}, \code{'m2'} is automatically selected.
It is recommended to use \code{'m2'} if \code{'m1'} encounters errors
with covariate-dependent models.}

\item{verbose}{A logical argument (default \code{FALSE}) to specify whether
to print information collected during the setup of the object(s).}

\item{fullframe}{A logical value indicating whether to return a
\code{fullframe} object in which \code{newdata} is bound to the summary
estimates. Note that \code{fullframe} cannot be used with \code{summary =
  FALSE}, and it is only applicable when \code{idata_method = 'm2'}. A
typical use case is when fitting a \code{univariate_by} model. This option
is mainly for internal use.}

\item{dummy_to_factor}{A named list (default \code{NULL}) to convert dummy
variables into a factor variable. The list must include the following
elements:
\itemize{
\item \code{factor.dummy}: A character vector of dummy variables to be
converted to factors.
\item \code{factor.name}: The name for the newly created factor variable
(default is \code{'factor.var'} if \code{NULL}).
\item \code{factor.level}: A vector specifying the factor levels.
If \code{NULL}, levels are taken from \code{factor.dummy}.
If \code{factor.level} is provided, its length must match
\code{factor.dummy}.
}}

\item{expose_function}{A logical value or \code{NULL} (default \code{FALSE}).
Controls whether Stan functions are exposed for post-processing.
\itemize{
\item \code{TRUE}: Explicitly exposes Stan functions saved from the model
fit. This is required when calculating \code{fit criteria} or
\code{bayes_R2} during model optimization.
\item \code{FALSE} (default): Stan functions are not exposed.
\item \code{NULL}: The setting is inherited from the original
\code{bsitar()} model fit configuration.
}
\strong{Note}: In the \code{\link[=optimize_model]{optimize_model()}} function, the default is
\code{NULL} (inheriting behavior), whereas other post-processing functions
default to \code{FALSE}.}

\item{usesavedfuns}{A logical value (default \code{NULL}) indicating whether
to use already exposed and saved Stan functions. This is typically set
automatically based on the \code{expose_functions} argument from the
\code{\link[=bsitar]{bsitar()}} call. Manual specification of \code{usesavedfuns} is rarely
needed and is intended for internal testing, as improper use can lead to
unreliable estimates.}

\item{clearenvfuns}{A logical value indicating whether to clear the exposed
Stan functions from the environment (\code{TRUE}) or not (\code{FALSE}). If
\code{NULL}, \code{clearenvfuns} is set based on the value of
\code{usesavedfuns}: \code{TRUE} if \code{usesavedfuns = TRUE}, or
\code{FALSE} if \code{usesavedfuns = FALSE}.}

\item{funlist}{A list (default \code{NULL}) specifying function names. This
is rarely needed, as required functions are typically retrieved
automatically. A use case for \code{funlist} is when \code{sigma_formula},
\code{sigma_formula_gr}, or \code{sigma_formula_gr_str} use an external
function (e.g., \code{poly(age)}). The \code{funlist} should include
function names defined in the \code{globalenv()}. For functions needing
both distance and velocity curves (e.g., \code{plot_curves(..., opt =
  'dv')}), \code{funlist} must include two functions: one for the distance
curve and one for the velocity curve.}

\item{xvar}{A character string (default \code{NULL}) specifying the
\code{'x'} variable. Rarely used because \code{xvar} is inferred
internally. A use case is when conflicting variables exist (e.g.,
\code{sigma_formula}) and user wants to set a specific variable as
\code{'x'}.}

\item{difx}{A character string (default \code{NULL}) specifying the
\code{'x'} variable that should be used for manual differentiation of the
distance curve. Internally, the \code{xvar} is set as \code{difx} if
specified. The argument \code{difx} is evaluated only when \code{dpar =
  'sigma'}, ignored otherwise. Note that argument \code{xvar} itself is rarely
used because \code{xvar} is inferred internally. A use case is when
conflicting variables exist (e.g., \code{sigma_formula}) and user wants to
set a specific variable as \code{'x'}.}

\item{idvar}{A character string (default \code{NULL}) specifying the
\code{'id'} variable. Rarely used because \code{idvar} is inferred
internally.}

\item{itransform}{A character string (default \code{NULL}) indicating the
variables names that are reverse transformed. Options are  \code{c("x",
  "y", "sigma")}. The \code{itransform} is primarily used to get the
\code{xvar} variable at original scale i.e., \code{itransform = 'x'}. To
turn of all transformations, use \code{itransform = ""}. when
\code{itransform = NULL}, the appropriate transformation for \code{xvar} is
selected automatically. Note that when no match for \code{xvar} is found in
the \code{data,frame}, the \code{itransform} will be ignored within the
calling function, \code{'prepare_transformations()'}.}

\item{newdata_fixed}{An indicator to specify whether to check data
format and structure for the user provided \code{newdata}, and apply needed
\code{prepare_data2} and \code{prepare_transformations}
(\code{newdata_fixed = NULL}, default), return user provided \code{newdata}
(\code{newdata = TRUE}) as it is without checking for the data format or
applying \code{prepare_data2} and \code{prepare_transformations}
(\code{newdata_fixed = 0}), check for the data format and if needed,
prepare data format using \code{prepare_data2} (\code{newdata_fixed = 1}),
or apply \code{prepare_transformations} only assuming that data format is
correct (\code{newdata_fixed = 2}). It is strongly recommended that user
either leave the \code{newdata = NULL} and \code{newdata_fixed = NULL} in
which case data used in the model fitting is automatically retrieved and
checked for the required data format and transformations, and if needed,
\code{prepare_data2} and \code{prepare_transformations} are applied
internally. The other flags provided for  \code{newdata_fixed = 0, 1, 2}
are mainly for the internal use during post-processing.}

\item{envir}{The environment used for function evaluation. The default is
\code{NULL}, which sets the environment to \code{parent.frame()}. Since
most post-processing functions rely on \pkg{brms}, it is recommended to set
\code{envir = globalenv()} or \code{envir = .GlobalEnv}, especially for
derivatives like velocity curves.}

\item{...}{Additional arguments passed to the \code{\link[brms:fitted.brmsfit]{brms::fitted.brmsfit()}}
function. For details on available options, please refer to
\code{brms::fitted.brmsfit()}.}
}
\value{
An array of predicted mean response values when \code{summarise =
  FALSE}, or a \code{data.frame} when \code{summarise = TRUE}. For further
details, refer to \link[brms:fitted.brmsfit]{brms::fitted.brmsfit}.
}
\description{
The \strong{fitted_draws()} function is a wrapper around the
\code{\link[brms:fitted.brmsfit]{brms::fitted.brmsfit()}} function, which allows users to obtain fitted
values (and their summaries) from the posterior draws. For more details,
refer to the documentation for \code{\link[brms:fitted.brmsfit]{brms::fitted.brmsfit()}}. An alternative
approach is to \code{\link[=marginal_draws]{marginal_draws()}} function which is based on the
\pkg{marginaleffects}.
}
\details{
The \strong{fitted_draws()} function computes the fitted values from
the posterior draws. While the \code{\link[brms:fitted.brmsfit]{brms::fitted.brmsfit()}} function from the
\pkg{brms} package can be used to obtain fitted (distance) values when the
outcome (e.g., height) is untransformed, it returns fitted values on the
log or square root scale if the outcome is transformed. In contrast,
\strong{fitted_draws()} returns fitted values on the original scale.
Additionally, \strong{fitted_draws()} computes the first derivative
(velocity) on the original scale, after applying the necessary
back-transformation. Apart from these differences, both
functions—\code{\link[brms:fitted.brmsfit]{brms::fitted.brmsfit()}} and \code{\link[=fitted_draws]{fitted_draws()}}—operate in the same
manner, allowing users to specify all options available in
\code{\link[brms:fitted.brmsfit]{brms::fitted.brmsfit()}}.
}
\examples{
\donttest{
# Fit Bayesian SITAR model 

# To avoid time-consuming model estimation, the Bayesian SITAR model fit to 
# the 'berkeley_exdata' has been saved as an example fit ('berkeley_exfit').
# See 'bsitar' function for details on 'berkeley_exdata' and 'berkeley_exfit'.

# Check if the model fit object 'berkeley_exfit' exists
berkeley_exfit <- getNsObject(berkeley_exfit)

model <- berkeley_exfit

# Population average distance curve
fitted_draws(model, deriv = 0, re_formula = NA)

# Individual-specific distance curves
fitted_draws(model, deriv = 0, re_formula = NULL)

# Population average velocity curve
fitted_draws(model, deriv = 1, re_formula = NA)

# Individual-specific velocity curves
fitted_draws(model, deriv = 1, re_formula = NULL)
}

}
\seealso{
\code{\link[brms:fitted.brmsfit]{brms::fitted.brmsfit()}}
}
\author{
Satpal Sandhu  \email{satpal.sandhu@bristol.ac.uk}
}
