% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bgm.R
\name{bgm}
\alias{bgm}
\title{Fit Bayesian SITAR growth curve model}
\usage{
bgm(
  x,
  y,
  id,
  data,
  df = 4,
  knots = NA,
  fixed = "a + b + c + d + e + f",
  random = "a + b + c + d + e + f",
  select_model = "sitar4r",
  xoffset = "mean",
  bstart = "apv",
  cstart = "pv",
  apv = NULL,
  pv = NULL,
  xfun = NULL,
  yfun = NULL,
  bound = 0.04,
  terms_rhs = NULL,
  a_formula = ~1,
  b_formula = ~1,
  c_formula = ~1,
  d_formula = ~1,
  e_formula = ~1,
  f_formula = ~1,
  g_formula = ~1,
  h_formula = ~1,
  i_formula = ~1,
  s_formula = ~1,
  a_formula_gr = ~1,
  b_formula_gr = ~1,
  c_formula_gr = ~1,
  d_formula_gr = ~1,
  e_formula_gr = ~1,
  f_formula_gr = ~1,
  g_formula_gr = ~1,
  h_formula_gr = ~1,
  i_formula_gr = ~1,
  s_formula_gr = ~1,
  a_formula_gr_str = NULL,
  b_formula_gr_str = NULL,
  c_formula_gr_str = NULL,
  d_formula_gr_str = NULL,
  e_formula_gr_str = NULL,
  f_formula_gr_str = NULL,
  g_formula_gr_str = NULL,
  h_formula_gr_str = NULL,
  i_formula_gr_str = NULL,
  s_formula_gr_str = NULL,
  sigma_formula = NULL,
  sigma_formula_gr = NULL,
  sigma_formula_gr_str = NULL,
  dpar_formula = NULL,
  autocor_formula = NULL,
  family = "gaussian()",
  group_arg = list(groupvar = NULL, by = NULL, cor = "un", cov = NULL, dist = "gaussian"),
  sigma_group_arg = list(groupvar = NULL, by = NULL, cor = "un", cov = NULL, dist =
    "gaussian"),
  univariate_by = list(by = NA, cor = "un"),
  multivariate = list(mvar = FALSE, cor = "un", rescor = TRUE),
  a_prior_beta = normal(ymean, ysd, autoscale = 2.5),
  b_prior_beta = normal(0, 2, autoscale = FALSE),
  c_prior_beta = normal(0, 0.25, autoscale = FALSE),
  d_prior_beta = normal(0, ysd, autoscale = FALSE),
  e_prior_beta = normal(0, 1, autoscale = FALSE),
  f_prior_beta = normal(0, 1, autoscale = FALSE),
  g_prior_beta = normal(0, 1, autoscale = FALSE),
  h_prior_beta = normal(0, 1, autoscale = FALSE),
  i_prior_beta = normal(0, 1, autoscale = FALSE),
  s_prior_beta = normal(0, lm, autoscale = 2.5),
  a_cov_prior_beta = normal(0, 5, autoscale = FALSE),
  b_cov_prior_beta = normal(0, 1, autoscale = FALSE),
  c_cov_prior_beta = normal(0, 0.1, autoscale = FALSE),
  d_cov_prior_beta = normal(0, 1, autoscale = FALSE),
  e_cov_prior_beta = normal(0, 1, autoscale = FALSE),
  f_cov_prior_beta = normal(0, 1, autoscale = FALSE),
  g_cov_prior_beta = normal(0, 1, autoscale = FALSE),
  h_cov_prior_beta = normal(0, 1, autoscale = FALSE),
  i_cov_prior_beta = normal(0, 1, autoscale = FALSE),
  s_cov_prior_beta = normal(0, 10, autoscale = FALSE),
  a_prior_sd = normal(0, ysd, autoscale = 2.5),
  b_prior_sd = normal(0, 2, autoscale = FALSE),
  c_prior_sd = normal(0, 0.15, autoscale = FALSE),
  d_prior_sd = normal(0, 1, autoscale = FALSE),
  e_prior_sd = normal(0, 1, autoscale = FALSE),
  f_prior_sd = normal(0, 1, autoscale = FALSE),
  g_prior_sd = normal(0, 1, autoscale = FALSE),
  h_prior_sd = normal(0, 1, autoscale = FALSE),
  i_prior_sd = normal(0, 1, autoscale = FALSE),
  s_prior_sd = normal(0, lm, autoscale = 2.5),
  a_cov_prior_sd = normal(0, 2, autoscale = FALSE),
  b_cov_prior_sd = normal(0, 1, autoscale = FALSE),
  c_cov_prior_sd = normal(0, 0.05, autoscale = FALSE),
  d_cov_prior_sd = normal(0, 1, autoscale = FALSE),
  e_cov_prior_sd = normal(0, 0.5, autoscale = FALSE),
  f_cov_prior_sd = normal(0, 0.5, autoscale = FALSE),
  g_cov_prior_sd = normal(0, 0.5, autoscale = FALSE),
  h_cov_prior_sd = normal(0, 0.5, autoscale = FALSE),
  i_cov_prior_sd = normal(0, 0.5, autoscale = FALSE),
  s_cov_prior_sd = normal(0, 0.5, autoscale = FALSE),
  a_prior_sd_str = NULL,
  b_prior_sd_str = NULL,
  c_prior_sd_str = NULL,
  d_prior_sd_str = NULL,
  e_prior_sd_str = NULL,
  f_prior_sd_str = NULL,
  g_prior_sd_str = NULL,
  h_prior_sd_str = NULL,
  i_prior_sd_str = NULL,
  s_prior_sd_str = NULL,
  a_cov_prior_sd_str = NULL,
  b_cov_prior_sd_str = NULL,
  c_cov_prior_sd_str = NULL,
  d_cov_prior_sd_str = NULL,
  e_cov_prior_sd_str = NULL,
  f_cov_prior_sd_str = NULL,
  g_cov_prior_sd_str = NULL,
  h_cov_prior_sd_str = NULL,
  i_cov_prior_sd_str = NULL,
  s_cov_prior_sd_str = NULL,
  sigma_prior_beta = normal(0, 1, autoscale = FALSE),
  sigma_cov_prior_beta = normal(0, 0.5, autoscale = FALSE),
  sigma_prior_sd = normal(0, 0.25, autoscale = FALSE),
  sigma_cov_prior_sd = normal(0, 0.15, autoscale = FALSE),
  sigma_prior_sd_str = NULL,
  sigma_cov_prior_sd_str = NULL,
  rsd_prior_sigma = normal(0, ysd, autoscale = 2.5),
  dpar_prior_sigma = normal(0, ysd, autoscale = 2.5),
  dpar_cov_prior_sigma = normal(0, 1, autoscale = FALSE),
  autocor_prior_acor = uniform(-1, 1, autoscale = FALSE),
  autocor_prior_unstr_acor = lkj(1),
  gr_prior_cor = lkj(1),
  gr_prior_cor_str = lkj(1),
  sigma_prior_cor = lkj(1),
  sigma_prior_cor_str = lkj(1),
  mvr_prior_rescor = lkj(1),
  init = NULL,
  init_r = NULL,
  a_init_beta = lm,
  b_init_beta = 0,
  c_init_beta = 0,
  d_init_beta = 0,
  e_init_beta = 0,
  f_init_beta = 0,
  g_init_beta = 0,
  h_init_beta = 0,
  i_init_beta = 0,
  s_init_beta = lm,
  a_cov_init_beta = 0,
  b_cov_init_beta = 0,
  c_cov_init_beta = 0,
  d_cov_init_beta = 0,
  e_cov_init_beta = 0,
  f_cov_init_beta = 0,
  g_cov_init_beta = 0,
  h_cov_init_beta = 0,
  i_cov_init_beta = 0,
  s_cov_init_beta = lm,
  a_init_sd = random,
  b_init_sd = random,
  c_init_sd = random,
  d_init_sd = random,
  e_init_sd = random,
  f_init_sd = random,
  g_init_sd = random,
  h_init_sd = random,
  i_init_sd = random,
  s_init_sd = random,
  a_cov_init_sd = random,
  b_cov_init_sd = random,
  c_cov_init_sd = random,
  d_cov_init_sd = random,
  e_cov_init_sd = random,
  f_cov_init_sd = random,
  g_cov_init_sd = random,
  h_cov_init_sd = random,
  i_cov_init_sd = random,
  s_cov_init_sd = random,
  sigma_init_beta = random,
  sigma_cov_init_beta = random,
  sigma_init_sd = random,
  sigma_cov_init_sd = random,
  gr_init_cor = random,
  sigma_init_cor = random,
  rsd_init_sigma = random,
  dpar_init_sigma = random,
  dpar_cov_init_sigma = random,
  autocor_init_acor = random,
  autocor_init_unstr_acor = random,
  mvr_init_rescor = random,
  r_init_z = random,
  vcov_init_0 = TRUE,
  jitter_init_beta = NULL,
  jitter_init_sd = NULL,
  jitter_init_cor = NULL,
  prior_data = NULL,
  init_data = NULL,
  init_custom = NULL,
  verbose = FALSE,
  expose_function = FALSE,
  get_stancode = FALSE,
  get_standata = FALSE,
  get_formula = FALSE,
  get_stanvars = FALSE,
  get_priors = FALSE,
  get_priors_eval = FALSE,
  get_init_eval = FALSE,
  validate_priors = FALSE,
  set_self_priors = NULL,
  set_replace_priors = NULL,
  set_same_priors_hierarchy = FALSE,
  outliers = NULL,
  unused = NULL,
  chains = 4,
  iter = 2000,
  warmup = floor(iter/2),
  thin = 1,
  cores = getOption("mc.cores", "optimize"),
  backend = getOption("brms.backend", "rstan"),
  threads = getOption("brms.threads", "optimize"),
  opencl = getOption("brms.opencl", NULL),
  normalize = getOption("brms.normalize", TRUE),
  algorithm = getOption("brms.algorithm", "sampling"),
  control = list(adapt_delta = 0.8, max_treedepth = 15),
  sample_prior = "no",
  save_pars = NULL,
  drop_unused_levels = TRUE,
  stan_model_args = list(),
  silent = 1,
  seed = 123,
  save_model = NULL,
  fit = NA,
  file = NULL,
  file_refit = getOption("brms.file_refit", "never"),
  future = getOption("future", FALSE),
  decomp = NULL,
  parameterization = NULL,
  ...
)
}
\arguments{
\item{x}{Specify predictor variable (typically age in years). For
\code{univariate} model, the \code{x} is a single variable whereas for
\code{univariate_by} and \code{multivariate} models, the \code{x} can be
same for all sub models or different for each sub model. As an example, when
fitting a bivariate model, the \code{x = list(x1, x2)} specifies that
\code{x1} is the predictor variable for the first sub model, and \code{x2}
for the second sub model. To specify \code{x1} as a common predictor
variable for both sub models, the argument \code{x} is defined as \code{x =
 list(x1)} or simply \code{x = x1}.}

\item{y}{Specify response variable (e.g., repeated height measurements). For
\code{univariate} and \code{univariate_by} models, the \code{y} is specified
as a single variable. For the \code{univariate_by} model, the response
variables for sub models are created internally and named after the factor
levels of the variable that is used to set up the \code{univariate_by}
model. As an example, for \code{univariate_by = sex}, the response variables
\code{Female} and  \code{Male} are created where \code{Female} is the first
level and \code{Male} is the second level of the factor variable,
\code{sex}. For \code{multivariate} model, the response variables are
specified as a list such as \code{y = list(y1, y2} where \code{y1} is the
response variable for the first sub model and \code{y2} for the second sub
model. Note that for \code{multivariate} model, data are not stacked but
rather response vectors of identical length and two variables in the
\code{data}.}

\item{id}{Specify a variable that uniquely identifies the individuals in the
data frame. For \code{univariate_by} and \code{multivariate} models, the
\code{id} can be same (typically) for sub models or different for each sub
model (see \code{x} for details).}

\item{data}{Data frame containing variables (such as \code{x}, \code{y},
\code{id} etc.).}

\item{df}{Specify the degrees of freedom for the natural cubic spline design
matrix (default \code{4}). The \code{df} is internally used to construct the
vector of knots (quantiles of \code{x} distribution) that are actually used
in the construction of the spline design matrix. For \code{univariate_by}
and \code{multivariate} models, the \code{df} can be same (e.g., \code{df  =
 4}) for sub models or different for each sub model such as
\code{df=list(4, 5)} where \code{df} is 4 is for the first sub model and 5
for the second sub model.}

\item{knots}{Specify a vector of knots for the natural cubic spline design
matrix. Default is \code{NULL} because the \code{df} is used (default, see
above). Note that \code{df} and \code{knots} can not be specified
simultaneously, and also both of them can not be \code{NULL}. In other
words, either \code{df} or \code{knots} must be specified, but not both.
Like \code{df}, the \code{knots} can be same for sub models or different for
each sub model when fitting \code{univariate_by} and \code{multivariate}
models.}

\item{fixed}{A character string specifying the fixed effects structure
(default \code{fixed = 'a+b+c'}).Note that  different fixed effect
structures can be specified when fitting \code{univariate_by} and
\code{multivariate} models. As an example, \code{fixed = list('a+b+c','
 a+b')} implies that the fixed effect structure for the first sub model is
\code{fixed = a+b+c}, and \code{fixed = 'a+b'} for the second sub model.}

\item{random}{A character string specifying the random effects structure
(default \code{fixed = 'a+b+c'}). The approach is same as described above
for the fixed effects structure (see \code{fixed}).}

\item{select_model}{A character string specifying the model to be fitted.
Allowed models are SITAR (\code{'sitar'}), the Preece-Baines model 1
(\code{'pb1'}), Preece-Baines model 2 (\code{'pb2'}) and the Preece-Baines
model 3 (\code{'pb3'}). The option \code{'sitar'} fits the default three
parameter model (i.e, \code{a+b+c}. see @details). The four parameters
version of the SITAR model (with an additional parameter, \code{d}), van be
fit by specifying \code{select_model} as \code{'sitar4fr'} or
\code{'sitar4r'}. The option \code{'sitar4fr'} includes parameter \code{d}
in both the fixed and the random effects structures of the SITAR model
whereas \code{'sitar4r'} implies that the parameter \code{d} will be
included only in the random effects structure of the SITAR model. Note that
for \code{'sitar4r'}, covariate(s) can not be specified for the parameter
\code{d}.}

\item{xoffset}{An optional character string, or a numeric value to set up the
origin of \code{x} (i.e., centering of the predictor variable, \code{x}).
The options available are \code{mean} (mean of x, i.e., \code{mean(x)}),
\code{max} (maximum value of x, i.e., \code{max(x)}), \code{min} (minimum
value of x, i.e., \code{min(x)}), \code{apv} (age at peak velocity estimated
from the velocity curve derived from the simple linear model fit to the
data), or any real number such as \code{xoffset = 12.5}. The default is
\code{xoffset = mean}.}

\item{bstart}{An optional character string or a numeric value to set up the
origin for the fixed effect parameter \code{b}. Options are same as
described above for the \code{xoffset}. The default is same as
\code{xoffset} i.e.,  \code{bstart = xoffset}.}

\item{cstart}{An optional character string or a numeric value to set up the
origin for the fixed effect parameter \code{c}. Options are \code{'pv'}
(peak velocity derived from the velocity curve of the simple linear model
fit to the data), or any real number such as \code{cstart = 2}. Note that
the actual value passed to the model is \code{log(cstart)} because
parameter \code{c} is estimated on the exponential scale. The default is
\code{cstart = 'pv'} i.e, log of the peak velocity.}

\item{apv}{An optional numeric value (default \code{NULL}) to set up the
initial value for the fixed effect parameter \code{b}. This is just an
alternative method of setting up the \code{bstart}.}

\item{pv}{An optional numeric value (default \code{NULL}) to set up the
initial value for the fixed effect parameter \code{c}. This is just an
alternative method of setting up the \code{cstart}. Note that like
\code{cstart}, the actual value passed to the model is \code{log(pv)}.}

\item{xfun}{An optional character string to specify the transformation of the
predictor variable, \code{x}. Options are \code{'log'} (logarithmic
transformation) and \code{'sqrt'} (square root transformation). The default
is \code{NULL} indicating that no transformation is applied i.e., the model
is fit to the data with original scale of the \code{x}. Like other
arguments, user can specify different \code{xfun} for \code{univariate_by}
and \code{multivariate} models (e.g., \code{xfun = list(log, sqrt)}).}

\item{yfun}{An optional character string to specify the transformation of the
response variable, \code{y} (default \code{NULL}). Options are same as
described above for the \code{xfun}.}

\item{bound}{An optional numeric value to extend the span of \code{x} by a
small value (default 0.04). See package \code{\link[sitar:sitar]{sitar::sitar()}} for details.}

\item{terms_rhs}{An optional character string (default \code{NULL}) to specify
terms on the right side of the response variable (separated by \code{|}) but
before the formula tilde i.e., before \code{~}. The \code{terms_rhs} is used
when fitting a measurement error model. As an example, consider fitting a
model with measurement error in the response specified as \code{bf(y |
 mi(sdy) ~ ..)} where \code{mi(sdy)} is passed to the \code{\link[brms:brmsformula]{brms::brmsformula()}}
as \code{terms_rhs = mi(sdy)}. For multivariate model, each outcome can have
its own measurement error variable i.e., \code{terms_rhs =
 list(mi(sdy1), mi(sdy2))}.}

\item{a_formula}{Formula for the fixed effect parameter, \code{a} (default
\code{~ 1}). User can specify different formula when fitting
\code{univariate_by} \code{multivariate} models. As an example
\code{a_formula = list(~1, ~1 + ov)} implies that the \code{a_formula} for
the first sub model includes only an intercept whereas the second sub model
includes an intercept and a covariate, \code{cov}. The covariate(s)  can be
continuous variable(s) or factor variable(s). For factor covariates, dummy
variables are created internally via the \code{\link[stats:model.matrix]{stats::model.matrix()}}). The
formula can include any combination of continuous and factor variables as
well as their interactions.}

\item{b_formula}{Formula for the fixed effect parameter, \code{b} (default
\code{~ 1}). See \code{a_formula} for details.}

\item{c_formula}{Formula for the fixed effect parameter, \code{c} (default
\code{~ 1}). See \code{a_formula} for details.}

\item{d_formula}{Formula for the fixed effect parameter, \code{d} (default
\code{~ 1}). See \code{a_formula} for details.}

\item{e_formula}{Formula for the fixed effect parameter, \code{e} (default
\code{~ 1}). See \code{a_formula} for details.}

\item{f_formula}{Formula for the fixed effect parameter, \code{f} (default
\code{~ 1}). See \code{a_formula} for details.}

\item{g_formula}{Formula for the fixed effect parameter, \code{g} (default
\code{~ 1}). See \code{a_formula} for details.}

\item{h_formula}{Formula for the fixed effect parameter, \code{h} (default
\code{~ 1}). See \code{a_formula} for details.}

\item{i_formula}{Formula for the fixed effect parameter, \code{i} (default
\code{~ 1}). See \code{a_formula} for details.}

\item{s_formula}{Formula for the fixed effect parameter, \code{s} (default
\code{~ 1}). The parameter \code{s} denotes the spline coefficients.}

\item{a_formula_gr}{Formula for the random effect parameter, \code{a} (default
\code{~ 1}). User can set up the group identifier and the correlation
structure for random effects via the \code{group_by} argument or the
vertical bar \code{|} approach. For example, consider random effects
\code{a}, \code{b}, and \code{c} specified as \code{a_formula_gr = ~1},
\code{b_formula_gr = ~1} and \code{c_formula_gr = ~1}. To specify the group
identifier (e.g., \code{id}) and an unstructured correlation structure, the
\code{group_by} argument is set up as \code{group_by = list(groupvar = id,
 cor = un)}. On the other hand, the vertical bar approach specifies the group
identifier and correlation structure directly within the formula argument
as follows: \code{a_formula_gr = ~ (1 |i|id)}, \code{b_formula_gr = ~
 (1|i|id)}, and \code{c_formula_gr = ~ (1 |i|id)} where  \code{i} within the
vertical bars \code{||} is just a placeholder. A common identifier (i.e.,
\code{i}) shared across random effect formulas are modeled as unstructured
correlated. For more details on the the vertical bar approach, please see
\code{\link[brms:brm]{brms::brm()}}.}

\item{b_formula_gr}{Formula for the random effect parameter, \code{b} (default
\code{~ 1}). See \code{a_formula_gr} for details.}

\item{c_formula_gr}{Formula for the random effect parameter, \code{c} (default
\code{~ 1}). See \code{a_formula_gr} for details.}

\item{d_formula_gr}{Formula for the random effect parameter, \code{d} (default
\code{~ 1}). See \code{a_formula_gr} for details.}

\item{e_formula_gr}{Formula for the random effect parameter, \code{e} (default
\code{~ 1}). See \code{a_formula_gr} for details.}

\item{f_formula_gr}{Formula for the random effect parameter, \code{f} (default
\code{~ 1}). See \code{a_formula_gr} for details.}

\item{g_formula_gr}{Formula for the random effect parameter, \code{g} (default
\code{~ 1}). See \code{a_formula_gr} for details.}

\item{h_formula_gr}{Formula for the random effect parameter, \code{h} (default
\code{~ 1}). See \code{a_formula_gr} for details.}

\item{i_formula_gr}{Formula for the random effect parameter, \code{i} (default
\code{~ 1}). See \code{a_formula_gr} for details.}

\item{s_formula_gr}{Formula for the random effect parameter, \code{s} (default
\code{~ 1}). See \code{a_formula_gr} for details.}

\item{a_formula_gr_str}{Formula for the random effect parameter, \code{a}
(default \code{NULL}) when fitting a hierarchical model with three or more
levels (e.g., when fitting a model to three level data with repeated
measurements (level 1) on individuals (level 2) nested further within the
growth studies (level 3)). When using the \code{a_formula_gr_str} argument,
only the vertical bar approach (see \code{a_formula} for details) can be
used to set up the group identifiers and the correlation structure. Consider
an example where formulas for random effect parameter \code{a}, \code{b},
and \code{c} for a three level model are specified as \code{a_formula_gr_str
 = ~ (1|i|id:study) + (1|i2|study)}, \code{b_formula_gr_str = ~
 (1|i|id:study) + (1|i2|study)} and \code{c_formula_gr_str = ~ (1|i|id:study)
 + (1|i2|study)} in which \code{|i|} and \code{|i2|} set up the unstructured
correlation structure for individual and study level random effects. Note
that \code{|i|} and \code{|i2|} need to be distinct because random effect
parameters are not allowed to be correlated across different levels of
hierarchy.}

\item{b_formula_gr_str}{Formula for the random effect parameter, \code{b}
(default \code{NULL}) when fitting a hierarchical model with three or more
levels. See \code{a_formula_gr_str} for details.}

\item{c_formula_gr_str}{Formula for the random effect parameter, \code{c}
(default \code{NULL}) when fitting a hierarchical model with three or more
levels. See \code{a_formula_gr_str} for details.}

\item{d_formula_gr_str}{Formula for the random effect parameter, \code{d}
(default \code{NULL}) when fitting a hierarchical model with three or more
levels. See \code{a_formula_gr_str} for details.}

\item{e_formula_gr_str}{Formula for the random effect parameter, \code{e}
(default \code{NULL}) when fitting a hierarchical model with three or more
levels. See \code{a_formula_gr_str} for details.}

\item{f_formula_gr_str}{Formula for the random effect parameter, \code{f}
(default \code{NULL}) when fitting a hierarchical model with three or more
levels. See \code{a_formula_gr_str} for details.}

\item{g_formula_gr_str}{Formula for the random effect parameter, \code{g}
(default \code{NULL}) when fitting a hierarchical model with three or more
levels. See \code{a_formula_gr_str} for details.}

\item{h_formula_gr_str}{Formula for the random effect parameter, \code{h}
(default \code{NULL}) when fitting a hierarchical model with three or more
levels. See \code{a_formula_gr_str} for details.}

\item{i_formula_gr_str}{Formula for the random effect parameter, \code{i}
(default \code{NULL}) when fitting a hierarchical model with three or more
levels. See \code{a_formula_gr_str} for details.}

\item{s_formula_gr_str}{Formula for the random effect parameter, \code{s}
(default \code{NULL}) when fitting a hierarchical model with three or more
levels. See \code{a_formula_gr_str} for details.}

\item{sigma_formula}{Formula for the fixed effect distributional parameter,
\code{sigma}. The \code{sigma_formula} is useful when including
covariates(s) for  the distributional parameter. Note that
\code{sigma_formula} estimates \code{sigma} parameter at \code{log} scale.
The \code{sigma_formula}, by default is \code{NULL} (i.e.,
\code{sigma_formula = NULL}.  because the \code{\link[brms:brm]{brms::brm()}} by default models
the \code{sigma} as a residual standard deviation (\strong{RSD}) parameter
at the link scale (prior and initial values for the \strong{RSD} are
specified via the \code{rsd_prior_sigma} and \code{rsd_init_sigma},
respectively. details on \code{rsd_prior_sigma} and \code{rsd_init_sigma}
are mentioned below in relevant sections). The \code{sigma_formula} along
with \code{sigma_formula_gr} and \code{sigma_formula_gr_str} arguments
allows hierarchical structure (estimation of random effects) for
\code{sigma}. This set up is similar to setting fixed and random effect
structures for other model parameters such as \code{a}, \code{b}, and
\code{c}. The \code{sigma_formula} sets up the fixed effect design matrix.
It is important to note that another alternative to set up the fixed effect
design matrix for distributional parameter \code{sigma} is to use
\code{dpar_formula}. An advantage of \code{dpar_formula} over
\code{sigma_formula} is that user can specify the linear and nonlinear
formulation as allowed by the \code{\link[brms:brmsformula-helpers]{brms::lf()}} and \code{\link[brms:brmsformula-helpers]{brms::nlf()}} syntax. Both
\code{\link[brms:brmsformula-helpers]{brms::lf()}} and \code{\link[brms:brmsformula-helpers]{brms::nlf()}} offer flexibility in centering of predictors
and enabling / disabling cell mean centering when excluding \code{intercept}
via \code{0 + } formulation. A disadvantage of using \code{sigma_formula} is
that it is not possible to include random effects for the \code{sigma}.
Note that \code{sigma_formula} and \code{dpar_formula} can not be specified
together. Lastly, when either \code{sigma_formula} or \code{dpar_formula},
the default estimation of the \strong{RSD} by \code{\link[brms:brm]{brms::brm()}} is automatically
turned off.}

\item{sigma_formula_gr}{Formula for the random effect parameter, \code{sigma}
(default \code{NULL}). See \code{a_formula_gr} for details.}

\item{sigma_formula_gr_str}{Formula for the random effect parameter,
\code{sigma} (default \code{NULL}) when fitting a hierarchical model with
three or more levels. See \code{a_formula_gr_str} for details.}

\item{dpar_formula}{Formula for the distributional fixed effect parameter,
\code{sigma} (default \code{NULL}). See \code{sigma_formula} for details.}

\item{autocor_formula}{Formula to set up the modelling of residuals
autocorrelation. (default \code{NULL}). Allowed options are: autoregressive
moving average (\code{arma}) of order \code{p} and \code{q}, autoregressive
(\code{ar}) of order \code{p}, moving average (\code{ma}) of order \code{q},
and unstructured (\code{unstr}). The \code{arma} is specified as
\code{~arms(p=1, q=1)}, \code{ar} as \code{~ar(p=1)}, \code{ma} as
\code{~ma(q=1)} and \code{unstr} as \code{~unstr(time, id))}. See
\code{\link[brms:brm]{brms::brm()}} for further details.}

\item{family}{Specify the family distribution (default \code{gaussian}) and
the link function (default \code{identity}). See \code{\link[brms:brm]{brms::brm()}} for details
on available distributions and link function, and how to specify each of
them. For \code{univariate_by} and \code{multivariate} models, the
\code{family} can be same \code{family = gaussian()} for sub models or
different for each sub model such as \code{family = list(gaussian(),
 student()} which sets \code{gaussian} distribution for the first sub model
and the \code{student_t} distribution for the second sub model.}

\item{group_arg}{Specify options (as a named list) for group-level random
effects via \code{groupvar}, \code{dist}, \code{cor}, and \code{by}
arguments. The \code{groupvar} specifies the subject identifier. In case
\code{groupvar = NULL} (default), the \code{groupvar} is taken from the
\code{id}). The default \code{dist} is \code{gaussian}. The \code{by}
(default \code{NULL}) is used to set up separate variance covariance
structures (i.e., standard deviation and correlation parameters) for groups
specified using a factor variable. For example, \code{by = sex} implies that
separate variance covariance structure are estimated for males and females.
The default \code{cor} is \code{un} for all three model settings, i.e.,
\code{univariate}, \code{univariate_by} and \code{multivariate}. The
alternative correlation structure available for \code{univariate} and
\code{univariate_by} models is \code{diagonal}. While the \code{cor = un}
models the full unstructured variance covariance structure, the \code{cor
 = diagonal} estimates only the variance (i.e, standard deviation) parameters
whereas the covariance (i.e., correlation) parameters are set to zero. Note
that only the \code{groupvar} sub option of the \code{group_arg} is passed
on to the \code{univariate_by} and \code{multivariate} models because they
these two arguments have their own sub options. Lastly, the \code{group_arg}
is completely ignored when user specify random effects via the vertical bar
("|") approach. Also, the \code{group_arg} is ignored for
\code{a_formula_gr_str}, \code{b_formula_gr_str}, and
\code{c_formula_gr_str} that are used when fitting a model with three or
more levels of hierarchy.}

\item{sigma_group_arg}{Specify options (as a named list) for distributional
random effects. The approach to set up the \code{sigma_group_arg} and the
options available are same as described above for the \code{group_arg}.}

\item{univariate_by}{Set up univariate-by-subgroup model fitting (default
\code{NULL}) via \code{by} and \code{cor} options. The \code{by} specifies
the variable (must be a factor variable) that is used to set up the sub
models whereas \code{cor} specifies the correlation structure. The options
available for \code{cor} are \code{un} and \code{diagonal}. The \code{un =
 un} (default) sets up the unstructured correlation structure for each sub
model whereas \code{diagonal} implies that only the variance (i.e, standard
deviation) for each sub model are estimated and the covariance (i.e.,
correlation) parameters are set as zero.}

\item{multivariate}{Set up the multivariate model fitting (default
\code{NULL}). The options available are \code{mvar} (logical, default
\code{FALSE}), \code{cor} (character string, default \code{un}), and
\code{rescor} (logical, default \code{TRUE}). The \code{mvar} indicates
whether to fit a multivariate model. The \code{cor} sets up the correlation
structure whereas \code{rescor} specifies  whether or not to estimate the
residual correlation across response variables. The sub options available
for \code{cor} are \code{un}, \code{diagonal} and \code{un_s}. The \code{un}
sets up the unstructured correlation implying that the group level random
effects across response variables are drawn for a joint multivariate normal
distribution with shared correlation parameters. The \code{cor = diagonal}
specifies that only the variance parameter are estimates for each sub model
whereas the correlation parameters set to zero. Option \code{cor = un_s}
allows for estimating unstructured variance covariance parameters separately
for each response variable.}

\item{a_prior_beta}{Specify priors for the fixed effect parameter, \code{a}.
Allowed distributions are \code{normal}, \code{student_t}, \code{cauchy},
\code{lognormal}, \code{uniform}, \code{exponential}, \code{gamma} and
\code{inv_gamma} (inverse gamma). See \code{\link[brms:set_prior]{brms::prior()}} for details. For each
distribution, options \code{lb} and \code{ub} can be used to set the upper
and lower bounds (default \code{NA} for both \code{lb} and \code{ub}). For
location-scale based distributions (\code{normal}, \code{student_t},
\code{cauchy},  and \code{lognormal}). An option \code{autosclae} (default
\code{FALSE}) allows auto scaling of the scale parameter by a numeric value.
Both \code{brms} and \code{rstanarm} packages perform similar auto scaling
under the hood. While \code{rstanarm} earlier used to set \code{autosclae}
as 2.5 (recently authors changed this behavior to \code{FALSE}), the
\code{brms} package sets it to 1 or 2.5 depending on the standard deviation
of the response variable (See \code{\link[brms:set_prior]{brms::prior()}}). The \code{bsitar} package
offers the flexibility of choosing the scaling factor as any real number
(e.g., \code{autosclae = 2.5}). When \code{autosclae = TRUE}, 2.5 is the
default scaling factor. For strictly positive distributions
(\code{exponential}, \code{gamma} and \code{inv_gamma}), the lower bound is
automatically set to zero (i.e., \code{lb = 0}). For uniform distribution,
an option \code{addrange} is available to symmetrically widen the prior
range. For example, prior \code{uniform(a, b, addrange = 5)} implies that
the lower and upper limits will be evaluated as \code{uniform(a-5, b+5)}.
For exponential distribution, the rate parameter is evaluated as inverse. In
other words, prior set as \code{exponential(10)} is translated to
\code{exponential(1.0 / 10.0)}. Also, note that user need not to specify
each option explicitly because the missing default options are added
automatically. For example, the prior specified as
\code{a_prior_beta = normal(location = 5, scale = 1, lb = NA, ub = NA,
 addrange = NA, autosclae = FALSE)}) is same as
\code{a_prior_beta = normal(5, 1)}). Lastly, the location parameter for the
location-scale based distributions can be specified as mean (by using
\code{ymean}) or the median (by using \code{ymedian}) of the response
variable. Similarly, the scale parameter can be set as the standard
deviation (by using \code{sd}) or the median absolute deviation (by using
\code{mad}) of the response variable. A few examples are \code{a_prior_beta
 = normal(ymean,ysd)}, \code{a_prior_beta = normal(ymean, ysd)}, and
\code{a_prior_beta = normal(ymedian, ymad)}. Another option available is to
use the coefficients from the simple linear  model applied to the data
(e.g., \code{lm(y ~ age, data = data})) as follows: \code{a_prior_beta =
 normal(lm, ysd)}). This is true even when model has covariates i.e.,
\code{lm(y ~ age + cov, data = data}). Note that options \code{ymean},
\code{ymedian}, \code{ysd}, \code{ymad}, \code{ymad} and \code{lm} are
available only for the fixed effect parameter, \code{a} and not for any
other parameter. For \code{univariate_by} \code{multivariate} models, priors
specified can be same for each sub model (e.g., \code{a_prior_beta =
 normal(5,1)}) or different for each sub such as \code{a_prior_beta =
 list(normal(5,1), normal(10, 5)}).}

\item{b_prior_beta}{Specify priors for the fixed effect parameter, \code{b}.
See \code{a_prior_beta} for details.}

\item{c_prior_beta}{Specify priors for the fixed effect parameter, \code{c}.
See \code{a_prior_beta} for details.}

\item{d_prior_beta}{Specify priors for the fixed effect parameter, \code{d}.
See \code{a_prior_beta} for details.}

\item{e_prior_beta}{Specify priors for the fixed effect parameter, \code{e}.
See \code{a_prior_beta} for details.}

\item{f_prior_beta}{Specify priors for the fixed effect parameter, \code{f}.
See \code{a_prior_beta} for details.}

\item{g_prior_beta}{Specify priors for the fixed effect parameter, \code{g}.
See \code{a_prior_beta} for details.}

\item{h_prior_beta}{Specify priors for the fixed effect parameter, \code{h}.
See \code{a_prior_beta} for details.}

\item{i_prior_beta}{Specify priors for the fixed effect parameter, \code{i}.
See \code{a_prior_beta} for details.}

\item{s_prior_beta}{Specify priors for the fixed effect parameter, \code{s}
(i.e., spline coefficients). The general approach is same as described
earlier for the fixed effect parameters  (see \code{a_prior_beta} for
details). For the location-scale based priors, option \code{lm} as location
sets the location parameter same as the spline coefficients obtained from
the simple linear model fit to the data. The option \code{lm} as scale
parameter sets the scale parameter same as the standard deviation of the
spline design matrix that was used in the fitting of the simple linear model
to the data. For parameter \code{s}, it make sense to use only the location
scale based prior distributions (e.g, \code{normal}, \code{student_t}, and
\code{cauchy}). Another choice could be the the \code{uniform} priors. For
\code{uniform} priors, the \code{addrange} option can be used to
symmetrically add range to the \code{lm} based spline coefficients. An
additional option available for the location scale based priors is
\code{sethp} (logical, default \code{FALSE}) which, when set as \code{TRUE},
allows for setting hierarchical priors for the \code{s} parameter. Instead
of setting prior as \code{s ~ normal(0, lm)} the hierarchical priors are set
as \code{s ~ normal(0, hp)} with \code{hp} defined as \code{hp ~ normal(0,
 lm)}. Note that the scale parameter for the \code{hp ~ normal(0, lm)} is
automatically taken from the \code{s ~ normal(0, hp)}. Setting \code{sethp =
 TRUE} implies that the scale for spline coefficients is estimated from the
data itself. The distribution of hierarchical priors is automatically
matched with the prior set for the \code{s} parameter, or else can be set by
the same \code{sethp} option. For example, \code{s_prior_beta = normal(0,
 lm, sethp = caucy)} will be translated to \code{s ~ normal(0, lm)}, \code{hp
 ~ caucy(0, lm)}.}

\item{a_cov_prior_beta}{Specify priors for the covariate(s) included in the
fixed effect parameter, \code{a}. The approach is same as described earlier
for the \code{a_prior_beta} except that options \code{ymean},
\code{ymedian}, \code{ysd}, and \code{ymad} are not allowed. The Option
\code{lm} for the location parameter sets \code{Intercept} coefficient
obtained from the simple linear model fit to the data. Note that that option
\code{lm} is allowed only for the \code{a_cov_prior_beta} and not for other
covariate(s) included in the other fixed or random effect parameters
described below. Lastly, separate priors can be specified for sub models
when fitting \code{univariate_by} and \code{a_prior_beta} models  (see
\code{a_prior_beta}).}

\item{b_cov_prior_beta}{Specify priors for the covariate(s) included in the
fixed effect parameter, \code{b} (see \code{a_cov_prior_beta} for details).}

\item{c_cov_prior_beta}{Specify priors for the covariate(s) included in the
fixed effect parameter, \code{c} (see \code{a_cov_prior_beta} for details).}

\item{d_cov_prior_beta}{Specify priors for the covariate(s) included in the
fixed effect parameter, \code{d} (see \code{a_cov_prior_beta} for details).}

\item{e_cov_prior_beta}{Specify priors for the covariate(s) included in the
fixed effect parameter, \code{e} (see \code{a_cov_prior_beta} for details).}

\item{f_cov_prior_beta}{Specify priors for the covariate(s) included in the
fixed effect parameter, \code{f} (see \code{a_cov_prior_beta} for details).}

\item{g_cov_prior_beta}{Specify priors for the covariate(s) included in the
fixed effect parameter, \code{g} (see \code{a_cov_prior_beta} for details).}

\item{h_cov_prior_beta}{Specify priors for the covariate(s) included in the
fixed effect parameter, \code{h} (see \code{a_cov_prior_beta} for details).}

\item{i_cov_prior_beta}{Specify priors for the covariate(s) included in the
fixed effect parameter, \code{i} (see \code{a_cov_prior_beta} for details).}

\item{s_cov_prior_beta}{Specify priors for the covariate(s) included in the
fixed effect parameter, \code{s}. The approach is same as described earlier
for the \code{a_cov_prior_beta}. For the location-scale based priors, the
option \code{lm} sets the location parameter same as the spline coefficients
obtained from fitting a simple linear to the data.}

\item{a_prior_sd}{Specify priors  for the random effect parameter, \code{a}.
The approach is same as described earlier for the fixed effect parameter,
\code{a} (See \code{a_prior_beta}) with the exception that location
parameter is always zero. As described earlier (see \code{a_prior_beta}),
priors for the \code{univariate_by} and \code{multivariate} models can be
same for each sub model or different for each sub model. The lower bound
zero is automatically set by the \code{brms::brm()}. Note that the prior is
on the standard deviation (which is the square root of the variance) and not
on the variance itself.}

\item{b_prior_sd}{Specify priors  for the random effect parameter, \code{b}.
See \code{a_prior_sd} for details.}

\item{c_prior_sd}{set Specify priors  for the random effect parameter,
\code{c}. See \code{a_prior_sd} for details.}

\item{d_prior_sd}{set Specify priors  for the random effect parameter,
\code{d}. See \code{a_prior_sd} for details.}

\item{e_prior_sd}{sset Specify priors  for the random effect parameter,
\code{e}. See \code{a_prior_sd} for details.}

\item{f_prior_sd}{sset Specify priors  for the random effect parameter,
\code{f}. See \code{a_prior_sd} for details.}

\item{g_prior_sd}{sset Specify priors  for the random effect parameter,
\code{g}. See \code{a_prior_sd} for details.}

\item{h_prior_sd}{sset Specify priors  for the random effect parameter,
\code{h}. See \code{a_prior_sd} for details.}

\item{i_prior_sd}{sset Specify priors  for the random effect parameter,
\code{i}. See \code{a_prior_sd} for details.}

\item{s_prior_sd}{sset Specify priors  for the random effect parameter,
\code{i}. See \code{a_prior_sd} for details.}

\item{a_cov_prior_sd}{Specify priors for the covariate(s) included in the
random effect parameter, \code{a}. The approach is same as described earlier
for the \code{a_cov_prior_beta} except that no pre-defined option (e.g.,
\code{lm}) is allowed (see \code{a_cov_prior_beta} for details).}

\item{b_cov_prior_sd}{Specify priors for the covariate(s) included in the
random effect parameter, \code{b}. See \code{a_cov_prior_sd} for details.}

\item{c_cov_prior_sd}{Specify priors for the covariate(s) included in the
random effect parameter, \code{c}. See \code{a_cov_prior_sd} for details.}

\item{d_cov_prior_sd}{Specify priors for the covariate(s) included in the
random effect parameter, \code{d}. See \code{a_cov_prior_sd} for details.}

\item{e_cov_prior_sd}{Specify priors for the covariate(s) included in the
random effect parameter, \code{e}. See \code{a_cov_prior_sd} for details.}

\item{f_cov_prior_sd}{Specify priors for the covariate(s) included in the
random effect parameter, \code{f}. See \code{a_cov_prior_sd} for details.}

\item{g_cov_prior_sd}{Specify priors for the covariate(s) included in the
random effect parameter, \code{g}. See \code{a_cov_prior_sd} for details.}

\item{h_cov_prior_sd}{Specify priors for the covariate(s) included in the
random effect parameter, \code{h}. See \code{a_cov_prior_sd} for details.}

\item{i_cov_prior_sd}{Specify priors for the covariate(s) included in the
random effect parameter, \code{i}. See \code{a_cov_prior_sd} for details.}

\item{s_cov_prior_sd}{Specify priors for the covariate(s) included in the
random effect parameter, \code{i}. See \code{a_cov_prior_sd} for details.}

\item{a_prior_sd_str}{Specify priors for the random effect parameter, \code{a}
when fitting a model with 3 or more hierarchy levels. The approach is same
as described earlier (see the \code{a_prior_beta_str}).}

\item{b_prior_sd_str}{Specify priors for the random effect parameter, \code{b}
when fitting a model with 3 or more hierarchy levels (see
\code{a_prior_sd_str}).}

\item{c_prior_sd_str}{Specify priors for the random effect parameter, \code{c}
when fitting a model with 3 or more hierarchy levels (see
\code{a_prior_sd_str}).}

\item{d_prior_sd_str}{Specify priors for the random effect parameter, \code{d}
when fitting a model with 3 or more hierarchy levels (see
\code{a_prior_sd_str}).}

\item{e_prior_sd_str}{Specify priors for the random effect parameter, \code{e}
when fitting a model with 3 or more hierarchy levels (see
\code{a_prior_sd_str}).}

\item{f_prior_sd_str}{Specify priors for the random effect parameter, \code{f}
when fitting a model with 3 or more hierarchy levels (see
\code{a_prior_sd_str}).}

\item{g_prior_sd_str}{Specify priors for the random effect parameter, \code{g}
when fitting a model with 3 or more hierarchy levels (see
\code{a_prior_sd_str}).}

\item{h_prior_sd_str}{Specify priors for the random effect parameter, \code{h}
when fitting a model with 3 or more hierarchy levels (see
\code{a_prior_sd_str}).}

\item{i_prior_sd_str}{Specify priors for the random effect parameter, \code{i}
when fitting a model with 3 or more hierarchy levels (see
\code{a_prior_sd_str}).}

\item{s_prior_sd_str}{Specify priors for the random effect parameter, \code{s}
when fitting a model with 3 or more hierarchy levels (see
\code{a_prior_sd_str}).}

\item{a_cov_prior_sd_str}{Specify priors for the covariate(s) included in the
random effect parameter, \code{a}  when fitting a model with 3 or more
hierarchy levels. The approach of setting up the priors is same as described
earlier for the \code{a_cov_prior_sd}.}

\item{b_cov_prior_sd_str}{Specify priors for the covariate(s) included in the
random effect parameter, \code{b} when fitting a model with 3 or more
hierarchy levels (see \code{a_cov_prior_sd_str}).}

\item{c_cov_prior_sd_str}{Specify priors for the covariate(s) included in the
random effect parameter, \code{c} when fitting a model with 3 or more
hierarchy levels (see \code{a_cov_prior_sd_str}).}

\item{d_cov_prior_sd_str}{Specify priors for the covariate(s) included in the
random effect parameter, \code{d} when fitting a model with 3 or more
hierarchy levels (see \code{a_cov_prior_sd_str}).}

\item{e_cov_prior_sd_str}{Specify priors for the covariate(s) included in the
random effect parameter, \code{e} when fitting a model with 3 or more
hierarchy levels (see \code{a_cov_prior_sd_str}).}

\item{f_cov_prior_sd_str}{Specify priors for the covariate(s) included in the
random effect parameter, \code{f} when fitting a model with 3 or more
hierarchy levels (see \code{a_cov_prior_sd_str}).}

\item{g_cov_prior_sd_str}{Specify priors for the covariate(s) included in the
random effect parameter, \code{g} when fitting a model with 3 or more
hierarchy levels (see \code{a_cov_prior_sd_str}).}

\item{h_cov_prior_sd_str}{Specify priors for the covariate(s) included in the
random effect parameter, \code{h} when fitting a model with 3 or more
hierarchy levels (see \code{a_cov_prior_sd_str}).}

\item{i_cov_prior_sd_str}{Specify priors for the covariate(s) included in the
random effect parameter, \code{i} when fitting a model with 3 or more
hierarchy levels (see \code{a_cov_prior_sd_str}).}

\item{s_cov_prior_sd_str}{Specify priors for the covariate(s) included in the
random effect parameter, \code{s} when fitting a model with 3 or more
hierarchy levels (see \code{a_cov_prior_sd_str}).}

\item{sigma_prior_beta}{Specify priors for the fixed effect distributional
parameter, \code{sigma}. The approach is same as described earlier for the
fixed effect parameter, \code{a} (See \code{a_prior_beta} for details).}

\item{sigma_cov_prior_beta}{Specify priors for the covariate(s) included in
the fixed effect distributional parameter, \code{sigma}. The approach is
same as described earlier for the covariate(s) included the fixed effect
parameter, \code{a} (see \code{a_cov_prior_beta} for details).}

\item{sigma_prior_sd}{Specify priors for the random effect distributional
parameter, \code{sigma}. The approach is same as described earlier the
random effect parameter \code{a} (see \code{a_prior_sd} for details).}

\item{sigma_cov_prior_sd}{Specify priors for the covariate(s) included in the
random effect distributional parameter, \code{sigma}. The approach is same
as described earlier the covariate(s) included in the random effect
parameter \code{a} (see \code{a_cov_prior_sd} for details).}

\item{sigma_prior_sd_str}{Specify priors for the the random effect
distributional parameter, \code{sigma} when fitting a model with 3 or more
hierarchy levels. The approach is same as described earlier for the random
effect parameter, \code{a} (See \code{a_prior_sd_str} for details).}

\item{sigma_cov_prior_sd_str}{Specify priors for the covariate(s) included in
the random effect distributional parameter, \code{sigma} when fitting a
model with 3 or more hierarchy levels. The approach is same as described
earlier for the covariate(s) included in the random effect parameter,
\code{a} (See \code{a_cov_prior_sd_str} for details).}

\item{rsd_prior_sigma}{Specify priors for the residual standard deviation
parameter \code{sigma}. This argument will only be evaluated when both
\code{dpar_formual} and \code{sigma_formual} are \code{NULL}. For location
scale based distributions, user can use specify the standard deviation
(\code{ysd}) or the median absolute deviation (\code{ymad}) as scale
parameter.}

\item{dpar_prior_sigma}{Specify priors for the fixed effect distributional
parameter \code{sigma}. The argument is evaluated only when
\code{sigma_formual} is \code{NULL}.}

\item{dpar_cov_prior_sigma}{Specify priors for the covariate(s) included in
the fixed effect distributional parameter \code{sigma}. The argument is
evaluated only when \code{sigma_formual} is \code{NULL}.}

\item{autocor_prior_acor}{Specify priors for the the autocorrelation
parameters \code{ar} and \code{ma} (see \code{autocor_formula} for details).
The only allowed distribution is uniform distribution bounded between -1 and
+1. For the recently added unstructured residual correlation structure, a
separate argument \code{autocor_prior_unstr_acor} is included (see below).}

\item{autocor_prior_unstr_acor}{Specify priors for the unstructured residual
autocorrelation structure. The only allowed prior distribution is
\code{lkj}. See \code{gr_prior_cor} for details on setting the \code{lkj}
prior.}

\item{gr_prior_cor}{Specify priors on the correlations for group-level random
effects. The only allowed distribution is \code{lkj} which has
a single parameter \code{eta} (see \code{\link[brms:set_prior]{brms::prior()}} for details).}

\item{gr_prior_cor_str}{Specify priors on the correlations for group-level
random effects when fitting a model with 3 or more hierarchy levels. The
approach is same as described above (See \code{gr_prior_cor}).}

\item{sigma_prior_cor}{Specify priors on the correlations for distributional
random effects \code{sigma}. The only allowed distribution is \code{lkj}
(see \code{gr_prior_cor} for details). Note that currently
\code{brms::brm()} does not allow for setting different \code{lkj} priors
for the distribution and group level random effects sharing the same group
identifier (because \code{brms::brm()} does not assign group for sigma).
Therefore, either create a copy of group identifier and use that but then
this will not allow correlation parameter across group random effects and
sigma.}

\item{sigma_prior_cor_str}{Specify priors on the correlations for
distributional random effects \code{sigma} when fitting a model with 3 or
more hierarchy levels. The approach is same as described above (See
\code{sigma_prior_cor}).}

\item{mvr_prior_rescor}{Specify priors on the residual correlation parameter
for the multivariate model. The only allowed distribution is \code{lkj}
(see \code{gr_prior_cor} for details).}

\item{init}{Specify initial values for the sampler. For \code{0}, all
parameters are initialized to zero. If \code{'random'}, Stan will randomly
generate initial values for each parameter within a range specified by the
\code{init_r} (see below), or between -2 and 2 in unconstrained space when
\code{init_r = NULL}. Another available option is \code{prior} which allows
setting initials based on the prior specified for each parameter. Lastly,
\code{NULL} option (the default) will let each of the parameter to have
initial values defined by the corresponding init arguments described below.}

\item{init_r}{Set range for the random generation of initial values. This
argument is evaluated only when the \code{init} is set as \code{'random'}
(see above). When \code{init = 'random'} and \code{init_r = NULL}, then
random initials values are generated within a range of -2 and 2
unconstrained space as explained above (see \code{init}).}

\item{a_init_beta}{Specify initial values for the fixed effect parameter,
\code{a}. Options available are \code{0}, \code{random} and \code{prior}. In
addition, user can specify \code{ymean} and \code{ymedian} to set initial as
the mean or the median of the response variable. Another option \code{lm}
sets initial values obtained from the simple linear model fitted to the data
(similar to the location parameter for prior on the fixed effect parameter
\code{a}, see \code{a_prior_beta}). Note that these options are available
only for the fixed effect parameter \code{a} and not for other parameters
described below. Lastly, For \code{univariate_by} and \code{multivariate}
models, the initials can be same (e.g., \code{a_init_beta = 0}) for sub
models or different for each sub model (e.g., \code{list(a_init_beta = 0,
 a_init_beta = lm)}).}

\item{b_init_beta}{Specify initial values for the fixed effect parameter,
\code{b}. See \code{a_init_beta} for details.}

\item{c_init_beta}{Specify initial values for the fixed effect parameter,
\code{c}. See \code{a_init_beta} for details.}

\item{d_init_beta}{Specify initial values for the fixed effect parameter,
\code{d}. See \code{a_init_beta} for details.}

\item{e_init_beta}{Specify initial values for the fixed effect parameter,
\code{e}. See \code{a_init_beta} for details.}

\item{f_init_beta}{Specify initial values for the fixed effect parameter,
\code{f}. See \code{a_init_beta} for details.}

\item{g_init_beta}{Specify initial values for the fixed effect parameter,
\code{g}. See \code{a_init_beta} for details.}

\item{h_init_beta}{Specify initial values for the fixed effect parameter,
\code{h}. See \code{a_init_beta} for details.}

\item{i_init_beta}{Specify initial values for the fixed effect parameter,
\code{i}. See \code{a_init_beta} for details.}

\item{s_init_beta}{Specify initial values for the fixed effect parameter,
\code{s} (spline coefficients). Options available are \code{0},
\code{random}, \code{prior}, and \code{lm}. See \code{a_init_beta} for
details.}

\item{a_cov_init_beta}{Specify initial values for covariate(s) included in the
fixed effect parameter, \code{a}. Options available are \code{0},
\code{random}, \code{prior} and \code{lm}. See \code{a_init_beta} for
details. The \code{lm} is available only for the \code{a_cov_init_beta} and
not for the covariate(s) included in other fixed effect parameters.}

\item{b_cov_init_beta}{Specify initial values for covariate(s) included in the
fixed effect parameter, \code{b}. See \code{a_cov_init_beta} for details.}

\item{c_cov_init_beta}{Specify initial values for covariate(s) included in the
fixed effect parameter, \code{c}. See \code{a_cov_init_beta} for details.}

\item{d_cov_init_beta}{Specify initial values for covariate(s) included in the
fixed effect parameter, \code{d}. See \code{a_cov_init_beta} for details.}

\item{e_cov_init_beta}{Specify initial values for covariate(s) included in the
fixed effect parameter, \code{e}. See \code{a_cov_init_beta} for details.}

\item{f_cov_init_beta}{Specify initial values for covariate(s) included in the
fixed effect parameter, \code{f}. See \code{a_cov_init_beta} for details.}

\item{g_cov_init_beta}{Specify initial values for covariate(s) included in the
fixed effect parameter, \code{g}. See \code{a_cov_init_beta} for details.}

\item{h_cov_init_beta}{Specify initial values for covariate(s) included in the
fixed effect parameter, \code{h}. See \code{a_cov_init_beta} for details.}

\item{i_cov_init_beta}{Specify initial values for covariate(s) included in the
fixed effect parameter, \code{i}. See \code{a_cov_init_beta} for details.}

\item{s_cov_init_beta}{Specify initial values for covariate(s) included in the
fixed effect parameter, \code{s} (spline coefficients). See
\code{a_cov_init_beta} for details. The option \code{lm} will set the
initial obtained from the simple linear model fitted to the data.}

\item{a_init_sd}{Specify initial value on the standard deviation for the group
level random effect parameter, \code{a}. Options available are \code{0},
\code{random} and \code{prior} as described above. Additional options
available are \code{ysd}, \code{ymad}, \code{lme_sd_a}, and \code{lm_sd_a}.
The \code{ysd} and \code{ymad} set the standard deviation (\code{sd}) and
the median absolute deviation (\code{mad}) of the response variable as
initial value. The \code{lme_sd_a} sets initial value based on the standard
deviation of random Intercept from the linear mixed model
(\code{nlme::lme()}) fitted to the data. The initial value set by the
\code{lm_sd_a} is square root of the residual variance from the simple
linear model applied to the data. Note that in case \code{nlme::lme()} fails
to converge for some reasons, then option \code{lm_sd_a} is set
automatically. Also note that these additional options are available only
for the random effect parameter \code{a} and not for other group level
random effects. Lastly, user can set same initials for sub models, or
different for each sub model when fitting \code{univariate_by} and
\code{multivariate} models.}

\item{b_init_sd}{Specify initial values for the group level random effect
parameter, \code{b}. See \code{a_init_sd} for details.}

\item{c_init_sd}{Specify initial values for the group level random effect
parameter, \code{c}. See \code{a_init_sd} for details.}

\item{d_init_sd}{Specify initial values for the group level random effect
parameter, \code{d}. See \code{a_init_sd} for details.}

\item{e_init_sd}{Specify initial values for the group level random effect
parameter, \code{e}. See \code{a_init_sd} for details.}

\item{f_init_sd}{Specify initial values for the group level random effect
parameter, \code{f}. See \code{a_init_sd} for details.}

\item{g_init_sd}{Specify initial values for the group level random effect
parameter, \code{g}. See \code{a_init_sd} for details.}

\item{h_init_sd}{Specify initial values for the group level random effect
parameter, \code{h}. See \code{a_init_sd} for details.}

\item{i_init_sd}{Specify initial values for the group level random effect
parameter, \code{i}. See \code{a_init_sd} for details.}

\item{s_init_sd}{Specify initial values for the group level random effect
parameter, \code{s}. See \code{a_init_sd} for details.}

\item{a_cov_init_sd}{Specify initial values for the covariate(s) included in
the random effect parameter, \code{a}. Options available are \code{0},
\code{random} and \code{prior}. See \code{a_cov_init_beta} for details.}

\item{b_cov_init_sd}{Specify initial values for the covariate(s) included in
the random effect parameter, \code{b}. See \code{a_cov_init_sd} for details.}

\item{c_cov_init_sd}{Specify initial values for the covariate(s) included in
the random effect parameter, \code{c}. See \code{a_cov_init_sd} for details.}

\item{d_cov_init_sd}{Specify initial values for the covariate(s) included in
the random effect parameter, \code{d}. See \code{a_cov_init_sd} for details.}

\item{e_cov_init_sd}{Specify initial values for the covariate(s) included in
the random effect parameter, \code{e}. See \code{a_cov_init_sd} for details.}

\item{f_cov_init_sd}{Specify initial values for the covariate(s) included in
the random effect parameter, \code{f}. See \code{a_cov_init_sd} for details.}

\item{g_cov_init_sd}{Specify initial values for the covariate(s) included in
the random effect parameter, \code{g}. See \code{a_cov_init_sd} for details.}

\item{h_cov_init_sd}{Specify initial values for the covariate(s) included in
the random effect parameter, \code{h}. See \code{a_cov_init_sd} for details.}

\item{i_cov_init_sd}{Specify initial values for the covariate(s) included in
the random effect parameter, \code{i}. See \code{a_cov_init_sd} for details.}

\item{s_cov_init_sd}{Specify initial values for the covariate(s) included in
the random effect parameter, \code{s}. See \code{a_cov_init_sd} for details.}

\item{sigma_init_beta}{Specify initial values for the fixed effect
distributional parameter, \code{sigma}. The approach is same as described
earlier for the fixed effect parameter \code{a} (See \code{a_init_beta} for
details).}

\item{sigma_cov_init_beta}{Specify initial values for the covariate(s)
included in the fixed effect distributional parameter, \code{sigma} (See
\code{a_cov_init_beta} for details).}

\item{sigma_init_sd}{Specify initial values for the distributional random
effect parameter, \code{sigma}. The approach is same as described earlier
for the group level random effect parameters such as \code{a} (See
\code{a_init_sd} for details).}

\item{sigma_cov_init_sd}{Specify initial values for the covariate(s) included
in the distributional random effect parameter, \code{sigma} (See
\code{a_cov_init_sd} for details).}

\item{gr_init_cor}{Specify initial values on correlation parameters for
group-level random effects parameters. Allowed options are \code{0},
\code{random} and \code{prior}.}

\item{sigma_init_cor}{Specify initial values on correlation parameters for
distributional random effects parameter \code{sigma}. Allowed options are
\code{0}, \code{random} and \code{prior}.}

\item{rsd_init_sigma}{Specify initial values for the residual standard
deviation parameter, \code{sigma}. Options available are \code{0},
\code{random} and \code{prior} as described earlier for the fixed effect
parameters. Additional options available are \code{lme_rsd}, and
\code{lm_rsd}. The \code{lme_rsd} sets initial value based on the standard
deviation of residuals obtained from the linear mixed model
(\code{nlme::lme()}) fitted to the data. The initial value set by the
\code{lm_rsd} is square root of the residual variance from the simple linear
model applied to the data. Note that in case \code{nlme::lme()} fails to
converge for some reasons, then option \code{lm_sd_a} is set automatically.
The argument \code{rsd_init_sigma} is evaluated when \code{dpar_formual} and
\code{sigma_formual} are set to \code{NULL}.}

\item{dpar_init_sigma}{Specify initial values for the distributional parameter
\code{sigma}. The approach and options available are same as described above
for the \code{rsd_init_sigma}. This argument is evaluated only when
\code{dpar_formual} and \code{sigma_formual} are not set \code{NULL}.}

\item{dpar_cov_init_sigma}{Specify initial values for the covariate(s)
included in the distributional parameter, \code{sigma}. Allowed options are
\code{0}, \code{random}, and \code{prior}.}

\item{autocor_init_acor}{Specify initial values for autocorrelation parameter
(see \code{autocor_formula} for details). Allowed options are \code{0},
\code{random}, and \code{prior}.}

\item{autocor_init_unstr_acor}{Specify initial values for unstructured
residual autocorrelation parameters. Allowed options are \code{0},
\code{random}, and \code{prior}. Note that the procedure to set initials
using \code{autocor_init_unstr_acor} is identical to the \code{gr_init_cor}.}

\item{mvr_init_rescor}{Specify initial values for the residual correlations
parameter for \code{multivariate} model. Allowed options are \code{0},
\code{random}, and \code{prior}.}

\item{r_init_z}{Specify initial values for the standardized group level
effects. These parameters are part of the Non-Centered Parameterization
(NCP) approach used in the \code{\link[brms:brm]{brms::brm()}}.}

\item{vcov_init_0}{A logical (default \code{TRUE}) to set initials for
variance (i.e, standard deviation) and covariance (i.e., correlation)
parameters as zero. This allows for setting custom initials for the fixed
effects parameters but zero for variance covariance parameters.}

\item{jitter_init_beta}{A value as proportion (between 0 and 1) used to
perturb the initials for fixed effect parameters. The default is \code{NULL}
indicating that same initials are used across all chains. An option of
setting \code{jitter_init_beta = 0.1} looked good during early testing.}

\item{jitter_init_sd}{A value as proportion (between 0 and 1) used to perturb
the initials for standard deviation of random effect parameters. The default
is \code{NULL} indicating that same initials are used across all chains.
An option of setting \code{jitter_init_beta = 0.01} looked good during early
testing.}

\item{jitter_init_cor}{A value as proportion (between 0 and 1) used to perturb
the initials for correlation of random effect parameters. The default is
\code{NULL} indicating that same initials are used across all chains. An
option of setting \code{jitter_init_beta = 0.001} looked good during early
testing.}

\item{prior_data}{An optional argument (a named list) that can be used to pass
information to the prior arguments. The default is \code{NULL}. This option
is particularly helpful when passing a long vector or a matrix for setting
priors. These vectors and matrices can be created in the R framework and
then passed using the \code{prior_data}. For example, to pass a vector of
location parameters when setting priors on covariates coefficient (with 10
dummy variables) included in the fixed effects parameter \code{a}, one can
create a named object prior_a_cov_location (\code{prior_a_cov_location =
 rnorm(10, 0, 1)}) and prior_a_cov_scale (\code{prior_a_cov_scale = rnorm(5,
 0, 1)}) in R  and then pass it as a named
list \code{prior_data = list(prior_a_cov_location = prior_a_cov_location,
 prior_a_cov_scale = prior_a_cov_scale,)} and then use it to set prior as
\code{a_cov_prior_beta} as \code{a_cov_prior_beta =
 normal(prior_a_cov_location, prior_a_cov_scale)}.}

\item{init_data}{An optional argument (a named list) that can be used to pass
information to the initial arguments. The approach is exact same as
described above for \code{prior_data}.}

\item{init_custom}{Specify a custom initials object (a named list). Note that
the named list is directly passed to the \code{init} argument without
checking for the dimensions.}

\item{verbose}{An optional logical (default \code{FALSE}) argument to print
information when preparing model formula, Stan function, priors, and
initials. As an example, the user might be interested in knowing the
response variables created for the sub model when fitting a
univariate-by-subgroup model. This information can then be setting matching
the desired order of options passed to each such model, See \code{df},
\code{df}, \code{prior}, \code{initials} for details.}

\item{expose_function}{An optional logical (default \code{FALSE}) to expose
Stan function used in model fitting. These functions are essential for
post-processing.}

\item{get_stancode}{An optional logical (default \code{FALSE}) to get the
stancode (see \code{\link[brms:stancode.brmsfit]{brms::stancode()}} for details).}

\item{get_standata}{An optional logical (default \code{FALSE}) to get the
standata (see \code{\link[brms:standata.brmsfit]{brms::standata()}} for details).}

\item{get_formula}{An optional logical (default \code{FALSE}) to get formula.
(see \code{\link[brms:brmsformula]{brms::brmsformula()}} for details).}

\item{get_stanvars}{An optional logical (default \code{FALSE}) to get
stanvars (see \code{\link[brms:stanvar]{brms::stanvar()}} for details).}

\item{get_priors}{An optional logical (default \code{FALSE}) to get priors.
(see \code{\link[brms:get_prior]{brms::get_prior()}} for details).}

\item{get_priors_eval}{An optional logical (default \code{FALSE}) to get priors
specified by the \code{bsitar::bgm()} via the \code{prepare_priors}.}

\item{get_init_eval}{An optional logical (default \code{FALSE}) to get the
initial values specified by the \code{bsitar::bgm()} via the
\code{prepare_initials}.}

\item{validate_priors}{An optional logical (default \code{FALSE}) to
validate the specified priors (see \code{\link[brms:validate_prior]{brms::validate_prior()}} for details).}

\item{set_self_priors}{An optional (default \code{NULL}) to specify
priors manually.}

\item{set_replace_priors}{An optional (default \code{NULL}) to replace
part of prior object. This is for internal use only.}

\item{set_same_priors_hierarchy}{An optional (default \code{NULL}) to replace
part of the prior object. This is for internal use only.}

\item{outliers}{An optional (default \code{NULL}) to remove velocity outliers.
The argument should be a named list to pass the information to the
\code{outliers} function. This is for internal use only.}

\item{unused}{An optional formula which contains variables that are unused
in the model but should still be stored in the model's data frame.
This can be useful, for example, if those variables are required for
post-processing the model.}

\item{chains}{Number of Markov chains (defaults to 4).}

\item{iter}{Number of total iterations per chain, including warmup (defaults
2000)}

\item{warmup}{A positive integer specifying number of warmup (aka burnin)
iterations. This also specifies the number of iterations used for stepsize
adaptation, so warmup draws should not be used for inference. The number
of warmup should not be larger than \code{iter} and the default is
\code{iter/1.33}.}

\item{thin}{Thinning rate. Must be a positive integer. Set \code{thin > 1} to
save memory and computation time if \code{iter} is large.}

\item{cores}{Number of cores to be used when executing the chains in parallel.
See \code{\link[brms:brm]{brms::brm()}} for details. Note that unlike \code{\link[brms:brm]{brms::brm()}} which sets
\code{cores=getOption("mc.cores", 1)}, the default in \code{bgm} is
\code{cores=getOption("mc.cores", 'optimize')} which optimizes the
utilization of system resources. The maximum number of cores that can be
deployed is calculated as the maximum number of available cores minus 1.
When the number of available cores is greater than the number of chains (see
\code{chains}), then number of cores is set equal to the number of chains.
Another option is to set \code{cores} as \code{getOption("mc.cores",
 'maximise')} which sets the number of cores as the maximum number of cores
available from the system regardless of the number of chains specified. Note
that the user can also set \code{cores} argument similar to the
\code{\link[brms:brm]{brms::brm()}} i.e., \code{getOption("mc.cores", 1)}. All these three options
can be set globally as \code{options(mc.cores = x}) where x can be
\code{optimize}, \code{maximise} or \code{1}. Lastly, the \code{cores} can
set by directly by specifying an integer e.g., \code{cores= 4}.}

\item{backend}{Character string naming the package to use as the backend for
fitting the Stan model. Options are \code{"rstan"} (the default) or
\code{"cmdstanr"}. Can be set globally for the current \R session via the
\code{"brms.backend"}. See \code{\link[brms:brm]{brms::brm()}} for details.}

\item{threads}{Number of threads to be used in within-chain parallelization.
Note that \code{\link[brms:brm]{brms::brm()}} sets this argument as
\code{getOption("brms.threads", NULL)} which means that no within-chain
parallelization is used by default. In contrast, to utilize the available
resources from the modern computing systems, the \code{bgm}, by default,
sets \code{threads} as \code{getOption("brms.threads", 'optimize')}. The
number of threads per chain is set as the maximum number of cores available
minus 1. Another option is to set \code{threads} as
\code{getOption("brms.threads", 'maximise')} which set the number threads
per chains same as the  maximum number of cores available. User can also set
the \code{threads} similar to the \code{brms} i.e.,
\code{getOption("brms.threads", NULL)}. All these three options can be set
globally as \code{options(brms.threads = x}) where x can be \code{optimize},
\code{maximise} or \code{NULL}.
Alternatively, the number of threads can be set as \code{threads
 = threading(x)} where \code{X} is an integer. Other arguments that can the
passed to the \code{threads} are \code{grainsize} and the \code{static}. See
\code{\link[brms:brm]{brms::brm()}} for further details on within-chain parallelization.}

\item{opencl}{The platform and device IDs of the OpenCL device to use for
fitting using GPU support. If you don't know the IDs of your OpenCL device,
\code{c(0,0)} is most likely what you need. For more details, see
\code{\link{opencl}}. Can be set globally for the current \R session via
the \code{"brms.opencl"} option.}

\item{normalize}{Indicates whether normalization constants should be included
in the Stan code (default \code{TRUE}). Setting it to \code{FALSE} requires
Stan version >= 2.25. If \code{FALSE}, sampling efficiency may be increased
but some post processing functions such as \code{\link[brms:bridge_sampler.brmsfit]{brms::bridge_sampler()}} will not
be available. This option can be controlled globally via the
\code{brms.normalize} option.}

\item{algorithm}{Character string naming the estimation approach to use.
Options are \code{"sampling"} for MCMC (the default), \code{"meanfield"}
for variational inference with independent normal distributions,
\code{"fullrank"} for variational inference with a multivariate normal
distribution, or \code{"fixed_param"} for sampling from fixed parameter
values. Can be set globally for the current \R session via the
\code{"brms.algorithm"} option (see \code{\link{options}}).}

\item{control}{A named \code{list} to control the sampler's behavior. The
default are same as \code{\link[brms:brm]{brms::brm()}} with the exception that the
\code{max_treedepth} has been increased form 10 to 15 to allow better
exploration of typically challenging posterior geometry posed by the
nonlinear model. However, another control parameter, the \code{adpat_delta}
which is also  often need to be increased for nonlinear model, has be set to
default setting as in \code{\link[brms:brm]{brms::brm()}} i.e, 0.8. This is to avoid unnecessarily
increasing the sampling time. See \code{\link[brms:brm]{brms::brm()}} for full details on control
parameters and their default values.}

\item{sample_prior}{Indicates whether to draw sample from priors in addition
to the posterior draws. Options are \code{"no"} (the default), \code{"yes"},
and \code{"only"}. Among others, these draws can be used to calculate Bayes
factors for point hypotheses via \code{\link[brms:hypothesis.brmsfit]{brms::hypothesis()}}. Please note that
improper priors are not sampled, including the default improper priors used
by \code{brm}. See \code{\link[brms:set_prior]{brms::set_prior()}} on how to set (proper) priors. Please
also note that prior draws for the overall intercept are not obtained by
default for technical reasons. See \code{\link[brms:brmsformula]{brms::brmsformula()}} how to obtain prior
draws for the intercept. If \code{sample_prior} is set to \code{"only"},
draws are drawn solely from the priors ignoring the likelihood, which allows
among others to generate draws from the prior predictive distribution. In
this case, all parameters must have proper priors.}

\item{save_pars}{An object generated by \code{\link{save_pars}} controlling
which parameters should be saved in the model. The argument has no
impact on the model fitting itself.}

\item{drop_unused_levels}{Should unused factors levels in the data be
dropped? Defaults to \code{TRUE}.}

\item{stan_model_args}{A \code{list} of further arguments passed to
\code{\link[rstan:stan_model]{rstan::stan_model}} for \code{backend =
  "rstan"} or \code{backend = "cmdstanr"}, which allows to change how
models are compiled.}

\item{silent}{Verbosity level between \code{0} and \code{2}. If \code{1} (the
default), most of the informational messages of compiler and sampler are
suppressed. If \code{2}, even more messages are suppressed. The actual
sampling progress is still printed. Set \code{refresh = 0} to turn this off
as well. If using \code{backend = "rstan"} you can also set
\code{open_progress = FALSE} to prevent opening additional progress bars.}

\item{seed}{The seed for random number generation to make results
reproducible. If \code{NA} (the default), \pkg{Stan} will set the seed
randomly.}

\item{save_model}{A character string or \code{NULL} (default). If not
\code{NULL}, then the model's Stan code is saved via in a text file named
after the string supplied in \code{save_model}.}

\item{fit}{An instance of S3 class \code{brmsfit} derived from a previous
fit; defaults to \code{NA}. If \code{fit} is of class \code{brmsfit}, the
compiled model associated with the fitted result is re-used and all
arguments modifying the model code or data are ignored. It is not
recommended to use this argument directly, but to call the
\code{\link[brms:update.brmsfit]{update}} method, instead.}

\item{file}{Either \code{NULL} or a character string. In the latter case, the
fitted model object is saved via \code{\link{saveRDS}} in a file named
after the string supplied in \code{file}. The \code{.rds} extension is
added automatically. If the file already exists, \code{brm} will load and
return the saved model object instead of refitting the model.
Unless you specify the \code{file_refit} argument as well, the existing
files won't be overwritten, you have to manually remove the file in order
to refit and save the model under an existing file name. The file name
is stored in the \code{brmsfit} object for later usage.}

\item{file_refit}{Modifies when the fit stored via the \code{file} argument
is re-used. Can be set globally for the current \R session via the
\code{"brms.file_refit"} option (see \code{\link{options}}).
For \code{"never"} (default) the fit is always loaded if it
exists and fitting is skipped. For \code{"always"} the model is always
refitted. If set to \code{"on_change"}, brms will
refit the model if model, data or algorithm as passed to Stan differ from
what is stored in the file. This also covers changes in priors,
\code{sample_prior}, \code{stanvars}, covariance structure, etc. If you
believe there was a false positive, you can use
\code{\link{brmsfit_needs_refit}} to see why refit is deemed necessary.
Refit will not be triggered for changes in additional parameters of the fit
(e.g., initial values, number of iterations, control arguments, ...). A
known limitation is that a refit will be triggered if within-chain
parallelization is switched on/off.}

\item{future}{Logical; If \code{TRUE}, the \pkg{\link[future:future]{future}}
package is used for parallel execution of the chains and argument
\code{cores} will be ignored. Can be set globally for the current \R
session via the \code{"future"} option. The execution type is controlled
via \code{\link[future:plan]{plan}} (see the examples section below).}

\item{decomp}{Optional name of the decomposition used for the
population-level design matrix. Defaults to NULL that is no decomposition.
Other options currently available are "QR" for the QR decomposition that
helps in fitting models with highly correlated predictors. Note that "QR"
decomposition is implementable only for the linear models, and therefore
applicable only for the restricted cubic spline (RCS) model.}

\item{parameterization}{A character string to specify either Non-centered
parameterization, NCP (\code{'ncp'}; or the Centered parameterization, CP
(\code{'cp'}  approach to draw group level random effect. The NCP is
generally recommended when likelihood is not strong (e.g., a few number of
and is the default (and only) approach implemented in the \code{\link[brms:brm]{brms::brm()}}.
The CP parameterization, on the other hand, is often considered more
efficient than NCP when a relatively large number of observations are
available across all individual. The 'relatively large number' is not
defined in the literature and we follow a general approach wherein CP
parameterization is used when each individual provides at least 10 repeated
measurements and NCP otherwise. Note this automatic behavior is set only
when the argument \code{parameterization = NULL} (default). To turn off
this automatic selection of parameterization and to set CP
parameterization, use \code{parameterization = 'cp'}, and
\code{parameterization = 'ncp'}. Please note that since \code{\link[brms:brm]{brms::brm()}} does
not offer CP parameterization, we first edit the \code{\link[brms:brm]{brms::brm()}} generated
\code{stancode} and then fit model using the \code{\link[rstan:rstan]{rstan::rstan()}} (or
\code{cmdstanr}, depending on the \code{backend} choice). Therefore, we
consider this CP parameterization as experimental and it may fail if
structure of the \code{\link[brms:brm]{brms::brm()}} generated \code{stancode} changes in future.}

\item{...}{Further arguments passed to \code{\link[brms:brm]{brms::brm()}}}
}
\value{
An object of class \code{brmsfit, bsiatr}, that contains the posterior
draws and other useful information about the model.
}
\description{
The \code{\link[=bgm]{bgm()}} is the main function in the \pkg{bsitar}
package that fits the Bayesian super imposition by translation and rotation
(SITAR). The SITAR model summarizes the growth curves from early childhood
through the adulthood (see @Details Section). The frequentist
version of the SITAR model can be fit by using an already available R
package, the \emph{sitar} \insertCite{R-sitar}{bsitar}. Besides Bayesian
implementation of the SITAR model, the \pkg{bsitar} package greatly enhances
the modelling capabilities of the SITAR model. For example, in addition to
the univariate analysis (i.e, modelling a single response variable), the
\pkg{bsitar} allows univariate-by-subgroup (modelling a single response
variable but for different subgroups defined by a factor variable) and
multivariate (simultaneous modelling of two or more responses) models (see
@details). The univariate-by-subgroup model is simply referred to as
univariate-by model and the argument to set up the this model is
\code{univariate_by} (see below). The multivariate model is set up the via
the \code{multivariate} argument (see below).
}
\details{
The SITAR is a shape-invariant nonlinear mixed effect growth curve
model that fits a population average (i.e., mean average) curve to the data,
and then aligns each individual's growth trajectory to this population
average curve via a set of three random effects, \code{size}, \code{timing}
and \code{intensity}. The concept of shape invariant model (SIM) was first
described by \insertCite{Lindstrom1995}{bsitar} and later used by
\insertCite{Beath2007;textual}{bsitar} to model infant growth data (birth to
2 years). The current version of the SITAR model is developed by
\insertCite{Cole2010;textual}{bsitar} and has been used extensively for
modelling human growth data \insertCite{@see
@nembidzaneUsingSITARMethod2020; @mansukoskiLifeCourseAssociations2019;
@coleFiftyYearsChild2018; @riddellClassifyingGestationalWeight2017;
@Sandhu2020}{bsitar}. As mentioned earlier (see @description), the
frequentist version of the SITAR model can be fit by an already available
R package, the \emph{sitar} \insertCite{R-sitar}{bsitar}.

The SITAR model implemented in the \strong{bsitar} package is same as \emph{sitar}
package with the exception that unlike \emph{sitar} which uses the B spline basis
for the natural cubic spline design matrix (by calling the \code{\link[splines:ns]{splines::ns()}})
\insertCite{R-splines}{bsitar}), the \emph{bsitar} constructs spline design
matrix by using the truncated power basis approach as described by
\insertCite{harrell2001regression}{bsitar}, and implemented in
\code{\link[Hmisc:rcspline.eval]{Hmisc::rcspline.eval()}} \insertCite{R-Hmisc}{bsitar}. Note that the
\strong{bsitar} package does not call the \code{\link[Hmisc:rcspline.eval]{Hmisc::rcspline.eval()}} but rather
constructs a custom function on the fly that is then included in the
functions block of the \emph{Stan} program and thus compiled (via the c++) during
the model fit.

Like \emph{sitar} package, the \strong{bsitar} package fits SITAR model with (usually)
up to three random effect parameters \insertCite{Cole2010}{bsitar}: the size
(\code{a}), the timing (\code{b}) and the intensity (\code{c}). In addition,
there is a slope parameter \code{d} that models the variability in the adult
slope of the growth curve (See \code{\link[sitar:sitar]{sitar::sitar()}} for details). Please note
that inclusion of \code{d} results in multicollinearity because inclusion of
\code{d} parameter involves a linear predictor term which is identical to
the first term of the spline design matrix created by the truncated power
basis approach (see \code{\link[Hmisc:rcspline.eval]{Hmisc::rcspline.eval()}} \insertCite{R-Hmisc}{bsitar}).

The \strong{bsitar} package heavily depends on another Bayesian R package, the
\emph{brms}  \insertCite{@see @R-brms; @brms2021}{bsitar}. The \emph{brms} can fit a
wide range of hierarchical linear and nonlinear regression models including
multivariate models. The \emph{brms} itself depends on the 'Stan' software for
full Bayesian inference \insertCite{@see @teamStanReferenceManual;
@gelman2015}{bsitar}.

Like \emph{brms}, the \strong{bsitar} package allows fitting a wide range of prior
specifications that encourage the users to apply prior distributions that
actually reflect their prior knowledge about the human growth processes such
as the timing of the age at peak growth velocity. The model fit can be
evaluated by means of posterior predictive check (see \code{\link[brms:pp_check.brmsfit]{brms::pp_check()}}).
Furthermore, models with different priors and/or growth curves (i.e., with
different \code{df} for splines) can be easily compared by using methods
already available in the \emph{brms} package such as the leave one out cross
validation (see \code{\link[brms:loo.brmsfit]{brms::loo()}}).

The excellent post-processing support offered by the \emph{brms} is further
augmented by many custom functions written for the \strong{bsitar} that allows
prediction and visualization of population average and individual specific
growth trajectories velocity curves. Furthermore, population average and
individual specific growth parameters such as age at peak growth velocity
(APGV) and the peak growth velocity (PGV) can be easily computed.

The \emph{bsitar} package allows three different model specifications:
\code{univariate}, \code{univariate_by} and \code{multivariate}. A
\code{univariate} model is a single model fit a single response variable
whereas both \code{univariate_by} and \code{multivariate} models comprise
two or more sub models. The \code{univariate_by} fits two or more separate
sub models for a single response variable defined by a factor variable (e.g,
sex). The data are typically stacked and the factor variable is used to
set-up the sub models by using the \code{subset} option available in the
\code{\link[brms:brm]{brms::brm()}}. The \code{multivariate} model fitting allows simultaneous
modelling of two or more response variables with joint a distribution of
random effects. For both \code{univariate_by} and \code{multivariate}
models, the \strong{bsitar} package allows full flexibility in specifying
separate predictor variables (\code{x}), subject identifiers (\code{id}),
degree of freedom (\code{df}) for design matrix as well as priors and the
initial values. Furthermore, to enhance the ease of specifying different
options and to make it user-friendly, there is no need to enclose the
character strings in single or double quotes. For example to specify the
\code{univariate_by} for sex, the \code{univariate_by = sex} is same as
\code{univariate_by = 'sex'} or \code{univariate_by = "sex"}. The same
applies for all character string options.
}
\examples{
\dontrun{
# Examples below fit SITAR model to the Berkley height data for 66 males and
# 70 females

# First two examples demonstrate fitting two separate univariate models for
# males and females and then a combined univariate-by-subgroup model. The
# third example shows multivariate model fitting. Each model is fit with 
# settings (4 chains with 2000 iterations per chain).

# As shown below, the univariate-by-subgroup model internally fits two
# sub-models, one for males and another for females. Advantage of fitting
# univariate-by-subgroup model is that posterior samples for all each sub 
# model are contained in a single framework which allows for a direct
# comparisons of parameters (e.g., hypothesis testing). The flexibility
# offered by the \bold{bsitar} package allows full control over the
# the sub-models (e.g. \code{df} for spline curve, \code{priors}  etc.).
#
# Fit 1 - Separate models for males and females with 5 df for males and
# 4 df for females.

# Prepare data
data(berkeley, package = "sitar")
data <- berkeley
rm(berkeley)

data <- data \%>\% 
  dplyr::select(id, age, height, sex) \%>\% 
  dplyr::filter(age \%in\% c(6:20) ) \%>\% 
  tidyr::drop_na(height)]
  
data$sex <- dplyr::recode_factor(data$sex, "1" = "Male", "2" = "Female")
  
  
data_males <- data \%>\% filter(sex == 'Male)
data_females <- data \%>\% filter(sex == 'Female)

# Fit model
fit_males <- bgm(x=age, y=height, id=id, data=heights, df=5)
fit_females <- bgm(x=age, y=height, id=id, data=heights, df=4)

# Generate a summary of results for males and females
summary(fit_males)
summary(fit_females)

# Perform posterior predictive checks for males and females
pp_check(fit_males)
pp_check(fit_females)

# plot distance and velocity curves for males and females
# Distance
plot(conditional_effects(fit_males, deriv = 0))
plot(conditional_effects(fit_females, deriv = 0))

# Velocity
plot(conditional_effects(fit_males, deriv = 1))
plot(conditional_effects(fit_females, deriv = 1))

# Fit 2 - A univariate-by-subgroup model is fit for sex (males and females) 
# with 5 df for males and 4 df for females. Since factor variable sex is 
# sorted alphabetically, the first reponse vector created is Female and 
# Male. As shown below, controlling any argument such as \code{df} is as 
# simple as enclosing it in list with arfuments separated by a comma. Same 
# approach applies for all argument including prior and initials.

# Fit model
fit_male_female <- bgm(x=age, y=height, id=id, data=heights,
univariate_by = sex, df=list(4,5))

# Generate a summary of results for males and females
summary(fit_male_female)

# Perform posterior predictive checks (specify response option resp = )
pp_check(fit_male_female, resp = 'Male')
pp_check(fit_male_female, resp = 'Female')

# plot distance and velocity curves for males and females
# Distance
plot(conditional_effects(fit_male_female, deriv = 0, resp = 'Male'))
plot(conditional_effects(fit_male_female, deriv = 0, resp = 'Female'))

# Velocity
plot(conditional_effects(fit_male_female, deriv = 1, resp = 'Male'))
plot(conditional_effects(fit_male_female, deriv = 1, resp = 'Female'))


# Fit 3 - multivariate model
# For demonstration purposes, we use the same heights data and artificially
# create the second outcome (height2) by rescaling the original first
# outcome (i.e., height). Again we use different degree of freedom (df) for
# each outcome. Here we also show how to use different priors and initials
# for some of the parameters.
data2 <- data \%>\% mutate(height2 = (height - 10) * 0.1)

# Fit model
# We specified multivariate = TRUE for fitting multivariate model. By
# default, the cor structure will be set to un for modelling unstructured
# varinace covaraince with joint distribution of groop level random effects.
# Also, option rescor for modelling residual correlation is set to TRUE
# (default). These options can be modified by explicitly setting the
# multivariate argument as a list, e.g., multivariate = list(mvar = TRUE,
# cor = un, rescor = TRUE). This allows changing the cor suboptions to un_s
# or diagonal, and rescor to FALSE (see \code{multivariate} for details).

# In the example shown below, we set df = 4 for the first outcome, height
# and df = 5 for the second outcome, height2. We set prior normal(ymean, ysd)
# for outcome height and cauchy(ymedian, 100) for the second outcome height2.
# Note data we set different autosclae values (2 for the first outcome and
# default FALSE for the second outcome). Also, we have set random initial
# for the first outcome and lm to the second outcome. Post-processing for
# multivariate model is same as univariate-by-subgroup model i.e., by using
# the resp = argument.

# Fit model
fit_mutivar <- bgm(x=age, y=list(height, height2), id=id, data=data2,
multivariate = TRUE,  df=list(4,5),
a_prior_beta = list(normal(ymean, ysd, autosclae = 2), cauchy(ymedian, 100)),
a_init_beta = list(random, lm))

# Generate a summary of results for height and height2
summary(fit_mutivar)

# Perform posterior predictive checks for height and height2
pp_check(fit_male_female, resp = 'height')
pp_check(fit_male_female, resp = 'height2')

# plot distance and velocity curves for height and height2
# Distance
plot(conditional_effects(fit_male_female, deriv = 0, resp = 'height'))
plot(conditional_effects(fit_male_female, deriv = 0, resp = 'height2'))

# Velocity
plot(conditional_effects(fit_male_female, deriv = 1, resp = 'height'))
plot(conditional_effects(fit_male_female, deriv = 1, resp = 'height2'))

}


}
\references{
\insertAllCited{}
}
\seealso{
\code{\link[brms:brm]{brms::brm()}} \code{\link[brms:brmsformula]{brms::brmsformula()}} \code{\link[brms:set_prior]{brms::prior()}}
}
\author{
Satpal Sandhu  \email{satpal.sandhu@bristol.ac.uk}
}
