temppp <- unlist(unname(temppp))
brmsinits <- brmsinits[!names(brmsinits) %in% keys]
xxx <- temppp
ilc <- list()
ilc_c <- 0
for (nysi_ in 1:nys) {
for (il in letters[1:4]) {
ilc_c <- ilc_c + 1
na <- paste0("^", il, nysi_)
nb <- paste0("^", il, "cov", nysi_)
nanb <- paste0(na, "|", nb)
if (length(xxx[grepl(nanb, names(xxx))]) > 0) {
ilc[[ilc_c]] <- xxx[grepl(nanb, names(xxx))]
}
}
}
ilc <- ilc[lengths(ilc) != 0]
names(ilc) <- paste0("sd_", 1:length(ilc))
for (sdi in names(ilc)) {
brmsinits[[sdi]] <- ilc[[sdi]]
}
c_it <- "z_"
brmsinits_names <- names(brmsinits)
keys <- brmsinits_names[grepl(c_it, brmsinits_names)]
temppp <- brmsinits[names(brmsinits) %in% keys]
for (zi in 1:length(ilc)) {
brmsinits[[paste0(c_it, zi)]] <- temppp[[zi]]
}
}
}  # if(!is.null(brmsinits)) {
# For multivariate, it makes sense to keep initials for betas only otherwise
# dimensional mismatch
if (!is.null(brmsinits) & length(initialslist) != nys) {
if (multivariate$mvar & multivariate$cor == "un") {
c_it_names <- c("sd_", "L_", "z_", "Lrescor")
for (c_it in c_it_names) {
brmsinits_names <- names(brmsinits)
keys <- brmsinits_names[grepl(c_it, brmsinits_names)]
brmsinits <- brmsinits[!names(brmsinits) %in% keys]
}
}
}
if (all(sapply("random", grepl, initialslist_s))) {
brmsinits <- "random"
brmsinits_r <- ept(init_rsi)
brmsinits_ <- NULL
} else if (all(sapply("0", grepl, initialslist_s))) {
brmsinits <- "0"
brmsinits_r <- ept(init_rsi)
brmsinits_ <- NULL
} else {
brmsinits <- brmsinits
brmsinits_r <- NULL
brmsinits_ <- ""
}
# Strip off initials attributes now
for (inm in names(brmsinits)) {
if (is.matrix(brmsinits[[inm]])) {
colnames(brmsinits[[inm]]) <- rownames(brmsinits[[inm]]) <- NULL
t__ <- brmsinits[[inm]]
if (!is.null(attr(t__, "dimnames")))
attr(t__, "dimnames") <- NULL
brmsinits[[inm]] <- t__
}
if (is.vector(brmsinits[[inm]])) {
t__ <- brmsinits[[inm]]
if (!is.null(attr(t__, "names")))
attr(t__, "names") <- NULL
brmsinits[[inm]] <- t__
}
}
if (!is.null(brmsinits_)) {
eval_inits_fun <-
function(inits,
jitter_init_beta,
jitter_init_sd,
jitter_init_cor,
digits) {
if (is.character(jitter_init_beta))
jitter_init_beta <- ept(jitter_init_beta)
if (is.character(jitter_init_sd))
jitter_init_sd <- ept(jitter_init_sd)
if (is.character(jitter_init_cor))
jitter_init_cor <- ept(jitter_init_cor)
if (!is.null(jitter_init_beta) &
!is.numeric(jitter_init_beta)) {
stop("Argument jitter_init_beta should be NULL or a numeric value")
}
if (!is.null(jitter_init_sd) &
!is.numeric(jitter_init_sd)) {
stop("Argument jitter_init_sd should be NULL or a numeric value")
}
if (!is.null(jitter_init_cor) &
!is.numeric(jitter_init_cor)) {
stop("Argument jitter_init_cor should be NULL or a numeric value")
}
jitter_x <- function(x, a, digits) {
x <- unname(x)
col <- c()
for (i in 1:length(x)) {
amount <- abs(x[i]) * a
col <- c(col, jitter(x[i], factor = 1, amount = amount))
}
col <- round(col, digits)
col
}
jitter_mat <- function(x, a, digits) {
mat_out <- x
x <- x[lower.tri(x)]
col <- c()
for (i in 1:length(x)) {
amount <- abs(x[i]) * a
col <- c(col, jitter(x[i], factor = 1, amount = amount))
}
col <- round(col, digits)
col <- ifelse(col > 1, 1, col)
col <- ifelse(col < -1, 1, col)
mat_out[lower.tri(mat_out)] <-
mat_out[upper.tri(mat_out)] <- col
return(mat_out)
}
eval_inits <- c()
for (i_init in names(inits)) {
if (grepl("^b_", i_init)) {
if (!is.null(jitter_init_beta)) {
values_i <-
jitter_x(inits[[i_init]], jitter_init_beta, digits = digits)
} else if (is.null(jitter_init_beta)) {
values_i <- inits[[i_init]]
values_i <- round(values_i, digits)
}
eval_inits[[i_init]] <- values_i
} else if (grepl("^sd_", i_init)) {
if (!is.null(jitter_init_sd)) {
values_i <- jitter_x(inits[[i_init]], jitter_init_sd, digits)
values_i <- abs(values_i)
values_i <-
ifelse(values_i <= 0, values_i + 0.01, values_i)
} else if (is.null(jitter_init_sd)) {
values_i <- inits[[i_init]]
values_i <- abs(round(values_i, digits))
values_i <-
ifelse(values_i <= 0, values_i + 0.01, values_i)
}
eval_inits[[i_init]] <- values_i
} else if (grepl("^L_", i_init)) {
if (!is.null(jitter_init_cor)) {
values_i <- jitter_mat(inits[[i_init]], jitter_init_cor, digits)
} else if (is.null(jitter_init_cor)) {
values_i <- inits[[i_init]]
values_i <- round(values_i, digits)
}
eval_inits[[i_init]] <- values_i
} else {
eval_inits[[i_init]] <- inits[[i_init]]
}
}  # for(i_init in names(inits)) {
eval_inits
return(eval_inits)
}
brmsinits <- lapply(1:brms_arguments$chains, function(id) {
eval_inits_fun(
inits = brmsinits,
jitter_init_beta = jitter_init_beta,
jitter_init_sd = jitter_init_sd,
jitter_init_cor = jitter_init_cor,
digits = 4
)
})
}
# Set brm arguments and fit model
setup_brms_args <-
function(formula,
prior,
stanvars,
data,
init_set,
init_str,
init_r,
seed,
verbose,
setarguments,
brmsdots) {
exc_args <- c("formula", "prior", "stanvars", "init", "data")
if (eval(setarguments$backend) == "rstan")
exc_args <- c(exc_args, "stan_model_args")
for (exc_argsi in exc_args) {
if (exc_argsi %in% names(setarguments))
setarguments[[exc_argsi]] <- NULL
}
setarguments$formula <- formula
setarguments$prior <- prior
setarguments$stanvars <- stanvars
setarguments$data <- data
if (eval(setarguments$backend) == "cmdstanr") {
if (all(sapply("0", grepl, init_str))) {
setarguments$init <- 0
custom_init <- FALSE
} else if (all(sapply("random", grepl, init_str))) {
setarguments$init <- NULL
custom_init <- FALSE
} else {
setarguments$init <- init_set
custom_init <- TRUE
}
if (!custom_init & !is.null(init_r)) {
setarguments$init <- init_r
}
}
if (eval(setarguments$backend) == "rstan") {
if (all(sapply("0", grepl, init_str))) {
setarguments$init <- "0"
custom_init <- FALSE
} else if (all(sapply("random", grepl, init_str))) {
setarguments$init <- "random"
custom_init <- FALSE
} else {
setarguments$init <- init_set
custom_init <- TRUE
}
if (!custom_init & !is.null(init_r)) {
setarguments$init_r <- init_r
}
}
if (eval(setarguments$backend) == "rstan" |
eval(setarguments$backend) == "cmdstanr") {
if (is.null(eval(setarguments$control))) {
setarguments$control <- list(adapt_delta = 0.8, max_treedepth = 15)
}
if (is.na(eval(setarguments$seed))) {
setarguments$seed <- seed
}
cores_ <- eval(setarguments$cores)
threads_ <- eval(setarguments$threads)
if(cores_ == "maximise") {
max.cores <-
as.numeric(future::availableCores(methods = "system", omit = 0))
if(max.cores < 1) max.cores <- 1
} else if(cores_ == "optimize") {
max.cores <-
as.numeric(future::availableCores(methods = "system", omit = 1))
if(max.cores < 1) max.cores <- 1
if(max.cores > eval(setarguments$chains)) {
max.cores <- eval(setarguments$chains)
}
} else if(!is.null(getOption('mc.cores')) &
cores_ != "maximise" &
cores_ != "optimize") {
max.cores <- getOption('mc.cores')
} else {
max.cores <- eval(setarguments$cores)
}
setarguments$cores <-  max.cores
if(!is.list(threads_)) {
if( is.character(threads_) & threads_ == "maximise") {
max.threads <-
as.numeric(future::availableCores(methods = "system", omit = 0))
if(max.threads < 1) max.threads <- 1
} else if( is.character(threads_) & threads_ == "optimize") {
max.threads <-
as.numeric(future::availableCores(methods = "system", omit = 1))
if(max.threads < 1) max.threads <- 1
max.threads <- floor(max.threads /  eval(setarguments$chains))
} else if(!is.null(getOption('brms.threads')) &
(is.character(threads_) & threads_ != "maximise") &
(is.character(threads_) & threads_ != "optimize")) {
max.threads <- getOption('brms.threads')
} else if(is.null(getOption('brms.threads')) &
(is.character(threads_) & threads_ != "maximise") &
(is.character(threads_) & threads_ != "optimize")) {
max.threads <- getOption('brms.threads')
} else {
max.threads <- eval(setarguments$cores)
}
setarguments$threads <-  threading(max.threads)
}
}
if (eval(setarguments$backend) == "cmdstanr") {
if (is.list(eval(setarguments$stan_model_args)) &
eval(length(setarguments$stan_model_args)) == 0) {
setarguments$stan_model_args <- list(stanc_options = list("O1"))
}
}
if (eval(setarguments$backend) == "rstan" &
packageVersion("rstan") < "2.26.1") {
# placeholder, will be updated later when rstan > 2.26.1 on CRAN
# brms takes care of threads options for rstan by the version
setarguments$threads <- setarguments$threads
}
if (length(brmsdots) > 0) {
setarguments <- c(setarguments, brmsdots)
}
return(setarguments)
}
if (verbose) {
setmsgtxt <- paste0("\n Setting-up brms arguments")
if (displayit == 'msg') {
message(setmsgtxt)
} else if (displayit == 'col') {
col <- setcolh
cat(paste0("\033[0;", col, "m", setmsgtxt, "\033[0m", "\n"))
}
}
brmsdots_ <- list(...)
brm_args <-
setup_brms_args(
formula = bformula,
prior = brmspriors,
stanvars = bstanvars,
data = brmsdata,
init = brmsinits,
init_str = initialslist_s,
init_r = brmsinits_r,
seed,
verbose,
setarguments = brms_arguments,
brmsdots = brmsdots_
)
if (verbose) {
setmsgtxt <- paste0("\n Fitting model")
if (displayit == 'msg') {
message(setmsgtxt)
} else if (displayit == 'col') {
col <- setcolh
cat(paste0("\033[0;", col, "m", setmsgtxt, "\033[0m", "\n"))
}
}
cat("\n")
insert_new_priors <- function(setdf_1, setdf_2) {
index <- row_number <- valid <- NA
setdf_1 <-
setdf_1 %>% dplyr::mutate(index = interaction(class, coef, group, nlpar)) %>%
dplyr::mutate(order = row_number()) %>%
dplyr::arrange(index)
setdf_2 <-
setdf_2 %>% dplyr::mutate(index = interaction(class, coef, group, nlpar)) %>%
dplyr::mutate(order = row_number()) %>%
dplyr::arrange(index)
vi_1 <- setdf_1 %>% dplyr::mutate(valid = ifelse(!(class == 'sd' & coef == ""), 1, 0)) %>%
data.frame() %>% dplyr::filter(valid == 1) %>% dplyr::select(index) %>% unlist() %>%
droplevels()
setdf_1 <- setdf_1 %>% dplyr::filter(!(class == 'sd' & coef == ""))
setdf_2 <- setdf_2 %>% dplyr::filter(!(class == 'sd' & coef == ""))
setdf_3 <- setdf_1[setdf_1$index %in% vi_1,]
setdf_2 <- setdf_2 %>% dplyr::filter(!index %in% vi_1)
setdf_4 <- rbind(setdf_2, setdf_3)
setdf_4 <- setdf_4 %>% dplyr::select(-c(index, order))
setdf_4
}
if(set_higher_levels) {
brmspriors_sdcor <- brmspriors %>%
dplyr::filter(class == 'sd' | class == 'cor')
brmspriors_sdcor_gr <- brmspriors_sdcor$group
brmsfit_sdcor <- do.call(get_prior, brm_args) %>%
dplyr::filter(class == 'sd' | class == 'cor')
brmsfit_sdcor_prior_gr <- brmsfit_sdcor %>%
dplyr::filter(!group %in%  brmspriors_sdcor_gr)
brmspriors_brmsfit_sdcor <- brmspriors %>%
dplyr::bind_rows(., brmsfit_sdcor_prior_gr)
brmspriors <- brmspriors_brmsfit_sdcor
}
brm_args$prior <- brmspriors
if(!is.null(set_self_priors) & !is.null(set_replace_priors)) {
stop("Amongst 'set_self_priors' and 'set_replace_priors' arguments,",
"\n ",
" only one can be specified at a time")
}
if(get_priors & get_set_priors & validate_priors &
get_stancode & get_standata) {
stop("Amongst 'get_priors' 'get_set_priors', 'validate_priors' ",
"\n ",
"'get_stancode' and 'get_standata' ",
"\n ",
" arguments, only one can be set to TRUE at a time")
}
exe_model_fit <- TRUE
if(get_stancode |
get_standata |
get_priors |
get_set_priors |
validate_priors) {
exe_model_fit <- FALSE
}
if(!exe_model_fit) {
if(get_stancode) {
return(do.call(make_stancode, brm_args))
} else if(get_standata) {
return(do.call(make_standata, brm_args))
} else if(get_priors) {
return(do.call(get_prior, brm_args))
} else if(get_set_priors) {
return(brm_args$prior)
} else if(validate_priors) {
return(do.call(validate_prior, brm_args))
}
}
if(exe_model_fit) {
if(!is.null(set_self_priors)) {
brm_args$prior <- set_self_priors
} else if(!is.null(set_replace_priors)) {
# brm_args$prior <- set_higher_priors(brmspriors, set_replace_priors)
brm_args$prior <- insert_new_priors(set_replace_priors, brmspriors)
} else if(is.null(set_self_priors) & is.null(set_replace_priors)) {
brm_args$prior <- brmspriors
}
if(!is.null(init_custom)) {
init_fun <- function(chain_id = 1) init_custom
if(!is.list(init_custom[[1]])) {
init_custom <- lapply(1:brm_args$chains, function(id) init_fun(chain_id = id))
} else {
if(length(init_custom) != length(brm_args$init)) {
stop("Custom initials specified via 'init_custom' argument must",
"\n ",
" be a single named list (e.g., custom_init = list(x= 2, xx=5)) ",
"\n ",
" or else a list of list matching the number of chains")
}
}
new_init_append <- list()
init_old <- brm_args$init
init_append <- init_custom
for (ilen in 1:length(init_old)) {
new_init_append[[ilen]] <- c(init_old[[ilen]], init_append[[ilen]])
}
brm_args$init <- new_init_append
}
brmsfit <- do.call(brm, brm_args)
# Add model info for post-processing
model_info <- list()
for (i in 1:length(xoffsetnamelist)) {
model_info[[xoffsetnamelist[[i]]]] <- xoffsetvaluelist[[i]]
}
for (i in 1:length(knotsnamelist)) {
model_info[[knotsnamelist[[i]]]] <- knotsvaluelist[[i]]
}
for (i in 1:length(fixednamelist)) {
model_info[[fixednamelist[[i]]]] <- fixedvaluelist[[i]]
}
for (i in 1:length(randomnamelist)) {
model_info[[randomnamelist[[i]]]] <- randomvaluelist[[i]]
}
for (i in 1:length(xfunnamelist)) {
model_info[[xfunnamelist[[i]]]] <- xfunvaluelist[[i]]
}
for (i in 1:length(yfunnamelist)) {
model_info[[yfunnamelist[[i]]]] <- yfunvaluelist[[i]]
}
for (i in 1:length(xxfunnamelist)) {
model_info[[xxfunnamelist[[i]]]] <- xxfunvaluelist[[i]]
}
for (i in 1:length(yyfunnamelist)) {
model_info[[yyfunnamelist[[i]]]] <- yyfunvaluelist[[i]]
}
for (i in 1:length(groupvarnamelist)) {
model_info[[groupvarnamelist[[i]]]] <- groupvarvaluelist[[i]]
}
for (i in 1:length(hierarchicalvarnamelist)) {
model_info[[hierarchicalvarnamelist[[i]]]] <- hierarchicalvarvaluelist[[i]]
}
for (i in 1:length(xnamelist)) {
model_info[[xnamelist[[i]]]] <- xvarvaluelist[[i]]
}
for (i in 1:length(ynamelist)) {
model_info[[ynamelist[[i]]]] <- yvarvaluelist[[i]]
}
for (i in 1:length(covnamelist)) {
model_info[[covnamelist[[i]]]] <- covvaluelist[[i]]
}
if(!is.na(univariate_by$by)) {
model_info[['make_bsitar_data']] <- make_bsitar_data
model_info[['org.ycall']] <- org.ycall
model_info[['subindicators']] <- subindicators
}
model_info[[SplineFun_name]] <- SplineFun_name
model_info[['multivariate']] <- multivariate$mvar
model_info[['univariate_by']] <- univariate_by$by
model_info[['nys']] <- nys
model_info[['ys']] <- ys
model_info[['call.bsitar']] <- mcall_
brmsfit$model_info <- model_info
# Expose Stan function
if (expose_function) {
if (verbose) {
setmsgtxt <-
paste0("\n Exposing Stan functions for post-processing")
if (displayit == 'msg') {
message(setmsgtxt)
} else if (displayit == 'col') {
col <- setcolh
cat(paste0("\033[0;", col, "m", setmsgtxt, "\033[0m", "\n"))
}
}
if (!verbose) {
setmsgtxt <-
paste0("\n Exposing Stan functions for post-processing..")
message(setmsgtxt)
}
brmsfit <- expose_bsitar_functions(brmsfit)
}
if (verbose) {
setmsgtxt <- paste0("\nModel Fitting complete")
if (displayit == 'msg') {
message(setmsgtxt)
} else if (displayit == 'col') {
col <- setcolh
cat(paste0("\033[0;", col, "m", setmsgtxt, "\033[0m", "\n"))
}
}
attr(brmsfit, 'class') <- c(attr(brmsfit, 'class'), 'bsitar')
return(brmsfit)
} # exe_model_fit
}
