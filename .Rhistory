#   brmspriors_sdcor_gr <- brmspriors_sdcor$group
#
#   brmsfit_sdcor <- do.call(get_prior, brm_args) %>%
#     dplyr::filter(class == 'sd' | class == 'cor')
#
#   brmsfit_sdcor_prior_gr <- brmsfit_sdcor %>%
#     dplyr::filter(!group %in%  brmspriors_sdcor_gr)
#
#   brmspriors_brmsfit_sdcor <- brmspriors %>%
#     dplyr::bind_rows(., brmsfit_sdcor_prior_gr)
#
#   brmspriors <- brmspriors_brmsfit_sdcor
# }
brm_args$prior <- brmspriors
if(!is.null(set_self_priors) & !is.null(set_replace_priors)) {
stop("Amongst 'set_self_priors' and 'set_replace_priors' arguments,",
"\n ",
" only one can be specified at a time")
}
if(get_priors & get_set_priors & validate_priors &
get_stancode & get_standata) {
stop("Amongst 'get_priors' 'get_set_priors', 'validate_priors' ",
"\n ",
"'get_stancode' and 'get_standata' ",
"\n ",
" arguments, only one can be set to TRUE at a time")
}
exe_model_fit <- TRUE
if(get_stancode |
get_standata |
get_priors |
get_set_priors |
validate_priors) {
exe_model_fit <- FALSE
}
# if(exe_model_fit) {
#   if(!is.null(set_self_priors)) {
#     brm_args$prior <- set_self_priors
#   } else if(!is.null(set_replace_priors)) {
#     # brm_args$prior <- insert_new_priors(set_replace_priors, brmspriors)
#     brm_args$prior <- brmspriors %>%
#       dplyr::filter(source == 'user') %>%
#       dplyr::bind_rows(., set_replace_priors)
#   } else if(is.null(set_self_priors) & is.null(set_replace_priors)) {
#     brm_args$prior <- brmspriors
#   }
# IMP - brms does not allow different lb conditions for sd parsm (e.e, all to be NA)
# Because prior function automatically sets lb 0 for positive priors such as exponentials
# the following is need
lbbb_ <- ubbb_ <- NULL
tempprior_hold <- brmspriors # brm_args$prior
setpriornamesorder <- colnames(tempprior_hold)
tempprior_hold$lbbb_ <- tempprior_hold$lb
tempprior_hold$ubbb_ <- tempprior_hold$ub
tempprior_hold$lb <- tempprior_hold$ub <- NULL
tempprior_hold <- tempprior_hold %>% dplyr::mutate(lbbb_ = dplyr::if_else(class == 'sd', NA, lbbb_))
tempprior_hold <- tempprior_hold %>% dplyr::mutate(ubbb_ = dplyr::if_else(class == 'sd', NA, ubbb_))
tempprior_hold$lb <- tempprior_hold$lbbb_
tempprior_hold$ub <- tempprior_hold$ubbb_
tempprior_hold$lbbb_ <- tempprior_hold$ubbb_ <- NULL
tempprior_hold <- tempprior_hold %>% dplyr::relocate(dplyr::all_of(setpriornamesorder))
# brm_args$prior <- tempprior_hold
brmspriors <-   tempprior_hold
brm_args$prior <- brmspriors
if(!exe_model_fit) {
if(get_priors) {
options(mc.cores = mc.cores_restore)
return(do.call(get_prior, brm_args))
} else if(get_standata) {
options(mc.cores = mc.cores_restore)
return(do.call(make_standata, brm_args))
} else if(get_stancode) {
options(mc.cores = mc.cores_restore)
return(do.call(make_stancode, brm_args))
} else if(get_set_priors) {
options(mc.cores = mc.cores_restore)
return(brm_args$prior)
} else if(validate_priors) {
options(mc.cores = mc.cores_restore)
return(do.call(validate_prior, brm_args))
}
}
if(exe_model_fit) {
if(!is.null(set_self_priors)) {
brm_args$prior <- set_self_priors
} else if(!is.null(set_replace_priors)) {
# brm_args$prior <- insert_new_priors(set_replace_priors, brmspriors)
brm_args$prior <- brmspriors %>%
dplyr::filter(source == 'user') %>%
dplyr::bind_rows(., set_replace_priors)
} else if(is.null(set_self_priors) & is.null(set_replace_priors)) {
brm_args$prior <- brmspriors
}
# txx <<- brm_args$prior
# stop()
# If initials are 0 or random, then set custom init to NULL
if(brm_args$backend == "rstan") {
if(length(brm_args$init) == 1) {
if(brm_args$init == "0") {
init_custom <- NULL
} else if(brm_args$init == "random") {
init_custom <- NULL
} else {
init_custom <- init_custom
}
} else {
init_custom <- init_custom
}
}
if(brm_args$backend == "cmdstanr") {
if(is.null(brm_args$init)) {
init_custom <- NULL
} else if(length(brm_args$init) == 1) {
if(brm_args$init == "0") {
init_custom <- NULL
} else if(brm_args$init == "random") {
init_custom <- NULL
} else if(brm_args$init == 0) {
init_custom <- NULL
} else {
init_custom <- init_custom
}
} else {
init_custom <- init_custom
}
}
if(!is.null(init_custom)) {
init_fun <- function(chain_id = 1) init_custom
if(!is.list(init_custom[[1]])) {
init_custom <-
lapply(1:brm_args$chains, function(id) init_fun(chain_id = id))
} else if(is.list(init_custom[[1]]) & length(init_custom) == 1) {
init_custom <- rep(init_custom, brm_args$chains)
} else {
if(length(init_custom) != length(brm_args$init)) {
stop("Custom initials specified via 'init_custom' argument must",
"\n ",
" be a single named list (e.g., custom_init = list(x= 2, xx=5)) ",
"\n ",
" or else a list of list matching the number of chains")
}
}
new_init_append <- list()
init_old <- brm_args$init
init_append <- init_custom
for (ilen in 1:length(init_old)) {
new_init_append[[ilen]] <- c(init_old[[ilen]], init_append[[ilen]])
}
brm_args$init <- new_init_append
}
brmsfit <- do.call(brm, brm_args)
# Add model info for post-processing
model_info <- list()
for (i in 1:length(xoffsetnamelist)) {
model_info[[xoffsetnamelist[[i]]]] <- xoffsetvaluelist[[i]]
}
for (i in 1:length(knotsnamelist)) {
model_info[[knotsnamelist[[i]]]] <- knotsvaluelist[[i]]
}
for (i in 1:length(fixednamelist)) {
model_info[[fixednamelist[[i]]]] <- fixedvaluelist[[i]]
}
for (i in 1:length(randomnamelist)) {
model_info[[randomnamelist[[i]]]] <- randomvaluelist[[i]]
}
for (i in 1:length(xfunnamelist)) {
model_info[[xfunnamelist[[i]]]] <- xfunvaluelist[[i]]
}
for (i in 1:length(yfunnamelist)) {
model_info[[yfunnamelist[[i]]]] <- yfunvaluelist[[i]]
}
for (i in 1:length(xxfunnamelist)) {
model_info[[xxfunnamelist[[i]]]] <- xxfunvaluelist[[i]]
}
for (i in 1:length(yyfunnamelist)) {
model_info[[yyfunnamelist[[i]]]] <- yyfunvaluelist[[i]]
}
for (i in 1:length(groupvarnamelist)) {
model_info[[groupvarnamelist[[i]]]] <- groupvarvaluelist[[i]]
}
for (i in 1:length(hierarchicalvarnamelist)) {
model_info[[hierarchicalvarnamelist[[i]]]] <- hierarchicalvarvaluelist[[i]]
}
for (i in 1:length(xnamelist)) {
model_info[[xnamelist[[i]]]] <- xvarvaluelist[[i]]
}
for (i in 1:length(ynamelist)) {
model_info[[ynamelist[[i]]]] <- yvarvaluelist[[i]]
}
for (i in 1:length(covnamelist)) {
model_info[[covnamelist[[i]]]] <- covvaluelist[[i]]
}
for (i in 1:length(sigmacovnamelist)) {
model_info[[sigmacovnamelist[[i]]]] <- sigmacovvaluelist[[i]]
}
if(!is.na(univariate_by$by)) {
model_info[['subindicators']] <- subindicators
}
model_info[[SplineFun_name]] <- SplineFun_name
model_info[['multivariate']] <- multivariate$mvar
model_info[['univariate_by']] <- univariate_by$by
model_info[['nys']] <- nys
model_info[['ys']] <- ys
model_info[['xs']] <- xs
model_info[['ids']] <- ids
model_info[['dfs']] <- dfs
model_info[['xfuns']] <- xfuns
model_info[['yfuns']] <- yfuns
model_info[['outliers']] <- outliers
model_info[['bsitar.data']] <- data.org.in
model_info[['call.full.bsitar']] <- call.full
model_info[['call.bsitar']] <- mcall_
brmsfit$model_info <- model_info
# Expose Stan function
if (expose_function) {
if (verbose) {
setmsgtxt <-
paste0("\n Exposing Stan functions for post-processing\n")
if (displayit == 'msg') {
message(setmsgtxt)
} else if (displayit == 'col') {
col <- setcolh
cat(paste0("\033[0;", col, "m", setmsgtxt, "\033[0m", "\n"))
}
}
if (!verbose) {
setmsgtxt <-
paste0("\n Exposing Stan functions for post-processing..\n")
message(setmsgtxt)
}
brmsfit <- expose_bsitar_functions(brmsfit)
}
if (!expose_function) {
brmsfit$model <- brmsfit$bmodel <- stancode(brmsfit)
}
if (verbose) {
setmsgtxt <- paste0("\nModel Fitting complete")
if (displayit == 'msg') {
message(setmsgtxt)
} else if (displayit == 'col') {
col <- setcolh
cat(paste0("\033[0;", col, "m", setmsgtxt, "\033[0m", "\n"))
}
}
attr(brmsfit, 'class') <- c(attr(brmsfit, 'class'), 'bsitar')
options(mc.cores = mc.cores_restore)
return(brmsfit)
} # exe_model_fit
}
mean = 1
sd = .1
shape = (mean/sd)^2
rate = mean/sd^2
shape <- 3
rate <- 1/.15
ggplot(data = tibble(x = seq(from = 0, to = 100, by = .1)),
aes(x = x, y = dgamma(x, shape = shape, rate = rate))) +
geom_area(color = "transparent",
fill = canva_pal("Green fields")(4)[2]) +
scale_x_continuous(NULL) +
scale_y_continuous(NULL, breaks = NULL) +
coord_cartesian(xlim = c(0, 10)) +
ggtitle(expression(brms~default~gamma(0.01*", "*0.01)~shape~prior))
library(tidyverse)
library(ggthemes)
mean = 1
sd = .1
shape = (mean/sd)^2
rate = mean/sd^2
shape <- 3
rate <- 1/.15
ggplot(data = tibble(x = seq(from = 0, to = 100, by = .1)),
aes(x = x, y = dgamma(x, shape = shape, rate = rate))) +
geom_area(color = "transparent",
fill = canva_pal("Green fields")(4)[2]) +
scale_x_continuous(NULL) +
scale_y_continuous(NULL, breaks = NULL) +
coord_cartesian(xlim = c(0, 10)) +
ggtitle(expression(brms~default~gamma(0.01*", "*0.01)~shape~prior))
qgamma(c(0.025, .975), shape, rate, lower.tail = T)
qnorm(c(0.025, .975), 0, 1, lower.tail = T)
mean = 1
sd = .1
shape = (mean/sd)^2
rate = mean/sd^2
shape <- 3
rate <- 1/1
ggplot(data = tibble(x = seq(from = 0, to = 100, by = .1)),
aes(x = x, y = dgamma(x, shape = shape, rate = rate))) +
geom_area(color = "transparent",
fill = canva_pal("Green fields")(4)[2]) +
scale_x_continuous(NULL) +
scale_y_continuous(NULL, breaks = NULL) +
coord_cartesian(xlim = c(0, 10)) +
ggtitle(expression(brms~default~gamma(0.01*", "*0.01)~shape~prior))
qgamma(c(0.025, .975), shape, rate, lower.tail = T)
qnorm(c(0.025, .975), 0, 1, lower.tail = T)
mean = 1
sd = .1
shape = (mean/sd)^2
rate = mean/sd^2
shape <- 2
rate <- 1/1
ggplot(data = tibble(x = seq(from = 0, to = 100, by = .1)),
aes(x = x, y = dgamma(x, shape = shape, rate = rate))) +
geom_area(color = "transparent",
fill = canva_pal("Green fields")(4)[2]) +
scale_x_continuous(NULL) +
scale_y_continuous(NULL, breaks = NULL) +
coord_cartesian(xlim = c(0, 10)) +
ggtitle(expression(brms~default~gamma(0.01*", "*0.01)~shape~prior))
qgamma(c(0.025, .975), shape, rate, lower.tail = T)
qnorm(c(0.025, .975), 0, 1, lower.tail = T)
mean = 1
sd = .1
shape = (mean/sd)^2
rate = mean/sd^2
shape <- 2
rate <- 1/2
ggplot(data = tibble(x = seq(from = 0, to = 100, by = .1)),
aes(x = x, y = dgamma(x, shape = shape, rate = rate))) +
geom_area(color = "transparent",
fill = canva_pal("Green fields")(4)[2]) +
scale_x_continuous(NULL) +
scale_y_continuous(NULL, breaks = NULL) +
coord_cartesian(xlim = c(0, 10)) +
ggtitle(expression(brms~default~gamma(0.01*", "*0.01)~shape~prior))
qgamma(c(0.025, .975), shape, rate, lower.tail = T)
qnorm(c(0.025, .975), 0, 1, lower.tail = T)
mean = 1
sd = .1
shape = (mean/sd)^2
rate = mean/sd^2
shape <- 2
rate <- 1/0.1
ggplot(data = tibble(x = seq(from = 0, to = 100, by = .1)),
aes(x = x, y = dgamma(x, shape = shape, rate = rate))) +
geom_area(color = "transparent",
fill = canva_pal("Green fields")(4)[2]) +
scale_x_continuous(NULL) +
scale_y_continuous(NULL, breaks = NULL) +
coord_cartesian(xlim = c(0, 10)) +
ggtitle(expression(brms~default~gamma(0.01*", "*0.01)~shape~prior))
qgamma(c(0.025, .975), shape, rate, lower.tail = T)
qnorm(c(0.025, .975), 0, 1, lower.tail = T)
mean = 1
sd = .1
shape = (mean/sd)^2
rate = mean/sd^2
shape <- 2
rate <- 1/0.15
ggplot(data = tibble(x = seq(from = 0, to = 100, by = .1)),
aes(x = x, y = dgamma(x, shape = shape, rate = rate))) +
geom_area(color = "transparent",
fill = canva_pal("Green fields")(4)[2]) +
scale_x_continuous(NULL) +
scale_y_continuous(NULL, breaks = NULL) +
coord_cartesian(xlim = c(0, 10)) +
ggtitle(expression(brms~default~gamma(0.01*", "*0.01)~shape~prior))
qgamma(c(0.025, .975), shape, rate, lower.tail = T)
qnorm(c(0.025, .975), 0, 1, lower.tail = T)
mean = 1
sd = .1
shape = (mean/sd)^2
rate = mean/sd^2
shape <- 2
rate <- 1/0.25
ggplot(data = tibble(x = seq(from = 0, to = 100, by = .1)),
aes(x = x, y = dgamma(x, shape = shape, rate = rate))) +
geom_area(color = "transparent",
fill = canva_pal("Green fields")(4)[2]) +
scale_x_continuous(NULL) +
scale_y_continuous(NULL, breaks = NULL) +
coord_cartesian(xlim = c(0, 10)) +
ggtitle(expression(brms~default~gamma(0.01*", "*0.01)~shape~prior))
qgamma(c(0.025, .975), shape, rate, lower.tail = T)
qnorm(c(0.025, .975), 0, 1, lower.tail = T)
mean = 1
sd = .1
shape = (mean/sd)^2
rate = mean/sd^2
shape <- 2
rate <- 1/0.2
ggplot(data = tibble(x = seq(from = 0, to = 100, by = .1)),
aes(x = x, y = dgamma(x, shape = shape, rate = rate))) +
geom_area(color = "transparent",
fill = canva_pal("Green fields")(4)[2]) +
scale_x_continuous(NULL) +
scale_y_continuous(NULL, breaks = NULL) +
coord_cartesian(xlim = c(0, 10)) +
ggtitle(expression(brms~default~gamma(0.01*", "*0.01)~shape~prior))
qgamma(c(0.025, .975), shape, rate, lower.tail = T)
qnorm(c(0.025, .975), 0, 1, lower.tail = T)
mean = 1
sd = .1
shape = (mean/sd)^2
rate = mean/sd^2
shape <- 2
rate <- 1/0.1
ggplot(data = tibble(x = seq(from = 0, to = 100, by = .1)),
aes(x = x, y = dgamma(x, shape = shape, rate = rate))) +
geom_area(color = "transparent",
fill = canva_pal("Green fields")(4)[2]) +
scale_x_continuous(NULL) +
scale_y_continuous(NULL, breaks = NULL) +
coord_cartesian(xlim = c(0, 10)) +
ggtitle(expression(brms~default~gamma(0.01*", "*0.01)~shape~prior))
qgamma(c(0.025, .975), shape, rate, lower.tail = T)
qnorm(c(0.025, .975), 0, 1, lower.tail = T)
install.packages('segmented')
library(nlme)
data(Cefamandole)
Cefamandole$lTime <-log(Cefamandole$Time)
Cefamandole$lconc <-log(Cefamandole$conc
o<-lme(lconc ~ lTime, random=~1|Subject, data=Cefamandole)
data(Cefamandole)
Cefamandole$lTime <-log(Cefamandole$Time)
Cefamandole$lconc <-log(Cefamandole$conc)
o<-lme(lconc ~ lTime, random=~1|Subject, data=Cefamandole)
o<-lme(lconc ~ lTime, random=~1|Subject, data=Cefamandole)
os<-segmented.lme(o, ~lTime, random=list(Subject=pdDiag(~1+lTime+U+G0)),
control=seg.control(n.boot=0, display=TRUE))
library(segmented)
os<-segmented.lme(o, ~lTime, random=list(Subject=pdDiag(~1+lTime+U+G0)),
control=seg.control(n.boot=0, display=TRUE))
slope(os
)
plot(os2, n.plot = c(3,3)
)
plot(os, n.plot = c(3,3)
)
plot(os)
fited(os)
fitted(os)
ls()
slope(os)
plot(os, n.plot = c(3,3), xscale=-1, yscale = -1) #
vcov.segmented.lme(os)
library(tidyverse)
Cefamandole %>% ggplot(., aes(x = lTime)) +  geom_line(aes(y = fitted(os)))
Cefamandole %>% ggplot(., aes(x = lTime)) +
geom_line(aes(y = fitted(os), group = Subject))
?segmented::fitted
fitted.segmented.lme
Cefamandole %>% ggplot(., aes(x = lTime)) +
geom_line(aes(y = fitted(os, level = 0), group = Subject))
os
Cefamandole %>% ggplot(., aes(x = lTime)) +
geom_line(aes(y = fitted(os, level = 0), group = Subject)) +
geom_vline(aes(xintercept = 4.43))
Cefamandole %>% ggplot(., aes(x = lTime)) +
geom_line(aes(y = fitted(os, level = 0), group = Subject)) +
geom_vline(aes(xintercept = 4.437674))
Cefamandole %>% ggplot(., aes(x = lTime)) +
geom_line(aes(y = fitted(os, level = 0))) +
geom_vline(aes(xintercept = 4.437674))
random.effects(os)
osx <- os
attr(osx, 'class') <- 'lme'
random.effects(osx)
b <- c(-1,rep(c(1.5,-1.5),l=15))
psi <- seq(.1,.9,l=15)
n <- 2000
x <- 1:n/n
X <- cbind(x, outer(x,psi,function(x,y)pmax(x-y,0)))
mu <- drop(tcrossprod(X,t(b)))
y<- mu + rnorm(n)*.02
par(mfrow=c(1,2))
#select number of breakpoints via the BIC (and plot it)
o<-selgmented(y, Kmax=20, type='bic', plot.ic=TRUE, check.dslope = FALSE)
plot(o, res=TRUE, col=2, lwd=3)
o1 <-selgmented(y, Kmax=20, type='bic') #check.dslope = TRUE by default
plot(o1, add=TRUE, col=3)
data(WaffleDivorce, package = "rethinking")
install.packages('rethinking')
install.packages(c("coda","mvtnorm","devtools","loo","dagitty","shape"))
devtools::install_github("rmcelreath/rethinking")
data(WaffleDivorce, package = "rethinking")
d <- WaffleDivorce
rm(WaffleDivorce)
d %>%
mutate(Divorce_distribution = str_c("Divorce ~ Normal(", Divorce, ", ", Divorce.SE, ")")) %>%
select(Loc, Divorce_distribution) %>%
head()
d
d
d %>%
mutate(Divorce_distribution = str_c("Divorce ~ Normal(", Divorce, ", ", Divorce.SE, ")")) %>%
select(Loc, Divorce_distribution) %>%
head()
remotes::install_github("Sandhu-SS/bsitar", auth_token = "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")
remotes::install_github("Sandhu-SS/bsitar", auth_token = "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")
install.packages('extraDistr')
install.packages('future.apply')
install.packages('jtools')
install.packages('patchwork')
install.packages('Rdpack')
install.packages('sitar')
install.packages('forcats')
install.packages('tidyr')
install.packages('bookdown')
install.packages('R.rsp')
install.packages('tidyverse')
devtools::install_github("Dschaykib/newsmd")
library(newsmd)
my_news <- news$new()
my_news
my_news <- newsmd()
my_news
my_news$add_version("0.0.1")
my_news$add_subtitle("Initial release")
my_news$write()
