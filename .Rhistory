mn <- 0
for (ikl in 1:length(grepl("^L_|^z_", ik_names))) {
mn <- mn + 1
ik_j_ <- ik_j_ + 1
list_ck_[[ik_j_]] <- initial_in_datazz[[ik_j]][[mn]]
}
names(list_ck_) <- ik_names
} else if (grepl("^Intercept_sigma", ik_names)) {
list_ck[[ik]] <- initial_in_datazz[[ik_j]]
names(list_ck[[ik]]) <- ik_names
} else if (multivariate$mvar & multivariate$rescor &
grepl("^Lrescor", ik_names)) {
list_ck_rescor[[ik]] <- initial_in_datazz[[ik_j]]
names(list_ck_rescor[[ik]]) <- ik_names
}
}
list_ck <- list_ck[lengths(list_ck) != 0]
keys    <- unique(unlist(lapply(list_ck, names)))
list_ck <-
setNames(do.call(mapply, c(FUN = c, lapply(
list_ck, `[`, keys
))), keys)
combined_inits <- c(list_ck, list_ck_)
}
if (is.null(gr_prior_cor) & is.null(sigma_prior_cor) ) {
# if (is.null(gr_prior_cor)) {
list_ck <- list_ck_z <- list_ck_sd <- list()
list_ck_rescor <- list()
ik_j <- ik_j_ <- 0
for (ik in 1:length(initial_in_datazz)) {
ik_j <- ik_j + 1
ik_names <- names(initial_in_datazz[[ik]])
if (!any(grepl("^L_|^z_|Intercept_sigma|Lrescor", ik_names))) {
list_ck[[ik]] <- initial_in_datazz[[ik_j]]
names(list_ck[[ik]]) <- ik_names
} else if (any(grepl("^L_|^z_", ik_names))) {
mn <- 0
for (ikl in 1:length(grepl("^L_|^z_", ik_names))) {
mn <- mn + 1
ik_j_ <- ik_j_ + 1
if (is.matrix(initial_in_datazz[[ik_j]][[mn]]))
list_ck_z[[ik_j_]] <- initial_in_datazz[[ik_j]][[mn]]
if (!is.matrix(initial_in_datazz[[ik_j]][[mn]]))
list_ck_sd[[ik_j_]] <- initial_in_datazz[[ik_j]][[mn]]
}
names(list_ck_z) <- ik_names[2]
names(list_ck_sd) <- ik_names[1]
} else if (grepl("^Intercept_sigma", ik_names)) {
list_ck[[ik]] <- initial_in_datazz[[ik_j]]
names(list_ck[[ik]]) <- ik_names
} else if (multivariate$mvar & multivariate$rescor &
grepl("^Lrescor", ik_names)) {
list_ck_rescor[[ik]] <- initial_in_datazz[[ik_j]]
names(list_ck_rescor[[ik]]) <- ik_names
}
}
list_ck <- list_ck[lengths(list_ck) != 0]
keys    <- unique(unlist(lapply(list_ck, names)))
list_ck <-
setNames(do.call(mapply, c(FUN = c, lapply(
list_ck, `[`, keys
))), keys)
list_ck_sd <- list_ck_sd[lengths(list_ck_sd) != 0]
# this on 9 5 23 to accomodate random = ''
if(length(list_ck_sd) != 0) {
for (list_ck_sd_i in 1:length(list_ck_sd)) {
if (length(list_ck_sd[[list_ck_sd_i]]) > 1) {
nami_ <-
paste0(names(list_ck_sd[[list_ck_sd_i]][1]),
"cov",
2:length(list_ck_sd[[list_ck_sd_i]]) - 1)
names(list_ck_sd[[list_ck_sd_i]]) <-
c(names(list_ck_sd[[list_ck_sd_i]][1]), nami_)
}
}
}
names(list_ck_sd) <-
rep(names(list_ck_sd[1]), length(list_ck_sd))
list_ck_sd2 <- list_ck_sd
list_ck_z <- list_ck_z[lengths(list_ck_z) != 0]
list_ck_z2 <- list()
# this on 9 5 23 to accomodate random = ''
if(length(list_ck_z) != 0) {
for (list_ck_i in 1:length(list_ck_z)) {
addelemnt <-
strsplit(gsub("\\+", " ", randomsi), " ")[[1]][list_ck_i]
list_ck_z2[[paste0("z", "_", addelemnt, resp_, list_ck_i)]] <-
list_ck_z[[list_ck_i]]
attr(list_ck_z2[[paste0("z", "_", addelemnt, list_ck_i)]], "names") <-
NULL
}
}
combined_inits <- c(list_ck, list_ck_sd2, list_ck_z2)
}
if (multivariate$mvar & multivariate$rescor) {
list_ck_rescor <- list_ck_rescor[lengths(list_ck_rescor) != 0]
list_ck_rescor <- list_ck_rescor[[1]]
combined_inits <- c(combined_inits, list_ck_rescor)
}
# convert vector of 's' initials to named individual (s1, s2)
if(select_model == "sitar") {
# Don't let when evaluating _str higher custom order
if("s_prior_beta" %in% custom_order_prior) first_loop <- TRUE else first_loop <- FALSE
if(first_loop) {
nlpar_s_init <- paste0('_s', 1:df)
if (grepl("~0", s_formulasi, fixed = T)) {
nlpar_s_init <-
rep(nlpar_s_init ,
times = 1,
each = length(scovcoefnames))
} else if (!grepl("~0", s_formulasi, fixed = T)) {
nlpar_s_init <- rep(nlpar_s_init , times = length(scovcoefnames))
}
subset_sparms <-
combined_inits[grepl(".*_s$", names(combined_inits))]
subset_sparms_name <- names(subset_sparms)
subset_sparms_numeric <- subset_sparms[[1]]
subset_sparms2 <- list()
subset_sparms2names <- c()
for (subset_sparmsi in 1:length(subset_sparms_numeric)) {
subset_sparms_namei <-
gsub("_s", nlpar_s_init[subset_sparmsi], subset_sparms_name)
subset_sparms2[[subset_sparms_namei]] <-
subset_sparms_numeric[subset_sparmsi]
subset_sparms2names <-
c(subset_sparms2names, subset_sparms_namei)
}
names(subset_sparms_numeric) <- subset_sparms2names
subset_sparms3 <- list()
for (isi in 1:df) {
subset_sparms3[[paste0("b", resp_, "_s", isi)]] <-
subset_sparms_numeric[grep(paste0("b", resp_, "_s", isi),
names(subset_sparms_numeric))]
}
subset_sparms <- subset_sparms3
subset_sparms <-
subset_sparms[!names(subset_sparms) %in% subset_sparms_name]
combined_inits <-
append(combined_inits, subset_sparms, after = grep(
paste0("^", subset_sparms_name, "$"),
names(combined_inits)
))
combined_inits <-
combined_inits[!names(combined_inits) %in% paste0("",
subset_sparms_name, "")]
initials <- combined_inits
} # if(first_loop) {
if(!first_loop) initials <- combined_inits
} # if(select_model == "sitar") {
if(select_model != "sitar") initials <- combined_inits
} # if (!is.null(initial_in_datazz)) {
if (is.null(initial_in_datazz)) {
initials <- NULL
}
###################3
stanvar_priors_names <- names(stanvars)
getaux <- "tau"
stanvar_priors_names_c <- c()
for (stanvar_priors_namesi in stanvar_priors_names) {
t <-
stanvar_priors_namesi[grep(paste0(getaux, '_scale', resp_),
stanvar_priors_namesi)]
t <- gsub(paste0('_scale', resp_), "", t, fixed = T)
stanvar_priors_names_c <- c(stanvar_priors_names_c, t)
}
add_tau <- list()
for (stanvar_priors_names_ci in stanvar_priors_names_c) {
fstandat <-
unlist(stanvars)[grep(paste0(
stanvar_priors_names_ci,
paste0('_scale', resp_, ".sdata")
), names(unlist(stanvars)))] %>% as.numeric()
add_tau[[paste0(stanvar_priors_names_ci, resp_)]] <-
rep(1, length(fstandat))
}
if (length(add_tau) == 0)
add_tau <- NULL
getaux <- "nu"
stanvar_priors_names_c <- c()
for (stanvar_priors_namesi in stanvar_priors_names) {
t <-
stanvar_priors_namesi[grep(paste0(getaux, '_scale', resp_),
stanvar_priors_namesi)]
t <- gsub(paste0('_scale', resp_), "", t, fixed = T)
stanvar_priors_names_c <- c(stanvar_priors_names_c, t)
}
add_nu <- list()
for (stanvar_priors_names_ci in stanvar_priors_names_c) {
add_nu[[paste0(stanvar_priors_names_ci, resp_)]] <-  5
}
if (length(add_nu) == 0)
add_nu <- NULL
initials <- c(initials, add_tau, add_nu)
################
revSubstr <- function(x_) {
x__ <- substr(x_, start = 1, stop = 3)
x___ <- paste0(rev(strsplit(x__, "_")[[1]]), collapse = "_")
x___ <- gsub(x__, x___, x_)
x___
}
tau_nu_init_list <- c(add_tau, add_nu)
if (length(tau_nu_init_list) != 0) {
names_tau_nu_parms <- names(tau_nu_init_list)
names_tau_nu_parmsi_c <- c()
for (names_tau_nu_parmsi in names_tau_nu_parms) {
plength <- length(tau_nu_init_list[[names_tau_nu_parmsi]])
revstr <- revSubstr(names_tau_nu_parmsi)
if (!grepl("^b_b", names_tau_nu_parmsi, fixed = F)) {
o <-
paste0("vector[",
plength,
"]",
" ",
revstr,
" = ",
names_tau_nu_parmsi,
";")
names_tau_nu_parmsi_c <- c(names_tau_nu_parmsi_c, o)
}
}
names_tau_nu_parmsi_c <- names_tau_nu_parmsi_c
names_tau_nu_parmsi_cc <-
paste(names_tau_nu_parmsi_c, collapse = "\n")
scode_auxillary <-
brms::stanvar(scode = names_tau_nu_parmsi_cc,
block = "genquant",
position = 'end')
} else if (length(tau_nu_init_list) == 0) {
scode_auxillary <- NULL
}
##################
# added on 11 6 2023
# out_listx <- initials
# for (ili in 1:length(initials)) {
#   if(length(out_listx[[ili]]) == 1) {
#     out_listx[[ili]] <- out_listx[[ili]]
#   } else if(length(out_listx[[ili]]) > 1 & is.vector(out_listx[[ili]])) {
#     out_listx[[ili]] <- array(out_listx[[ili]], dim = length(out_listx[[ili]]))
#   }
#   if(ili == 'ar' | ili == 'ma') {
#     out_listx[[ili]] <- array(out_listx[[ili]], dim = length(out_listx[[ili]]))
#   }
# }
out_listx <- initials
for (ili in names(initials)) {
if(length(out_listx[[ili]]) == 1) {
out_listx[[ili]] <- out_listx[[ili]]
# here also need array for a b c d e
# but not for sigma when sigma ~ not used but default rsd formulation
if(nys == 1) sigma_par_name_rsd <- "sigma"
if(nys > 1) sigma_par_name_rsd <- paste0('sigma', resp_)
if(ili != sigma_par_name_rsd) {
out_listx[[ili]] <- array(out_listx[[ili]], dim = length(out_listx[[ili]]))
}
} else if(length(out_listx[[ili]]) > 1 & is.vector(out_listx[[ili]])) {
out_listx[[ili]] <- array(out_listx[[ili]], dim = length(out_listx[[ili]]))
}
if(is.na(ili)) ili <- "xxxxxxxxxxxxxx"
# for ar and ma, it is always vector , so array
if(ili == 'ar' | ili == 'ma') {
out_listx[[ili]] <- array(out_listx[[ili]], dim = length(out_listx[[ili]]))
}
}
initials <- out_listx
# when sigma  formula is ~1+.., then first element is Intercept_sigma and the
# remaining are b_sigma
initialsx <- out_listx
if(!sigma_form_0) {
if(nys == 1) {
sigma_par_name <- 'b_sigma'
Intercept_sigma <- 'Intercept_sigma'
} else if(nys > 1) {
sigma_par_name <- paste0('b_sigma', resp_)
Intercept_sigma <- paste0('Intercept_sigma', resp_)
}
if(!is.null(initialsx[[sigma_par_name]])) {
g_sigma_i <- initialsx[[sigma_par_name]]
initialsx[[Intercept_sigma]] <- g_sigma_i[1]
if(length(g_sigma_i) > 1) {
initialsx[[sigma_par_name]] <-   array(g_sigma_i[2:length(g_sigma_i)],
dim = length(g_sigma_i[2:length(g_sigma_i)]))
} # if(length(g_sigma_i) > 1) {
}
}
initials <- initialsx
# re create symmetric square Lcortime which is flattened to a vector
# this could have have done above like L_|z_|Lrescor etc but this is same
if(!is.null(initials[['Lcortime']])) {
NC_dims         <- ept(cortimeNlags) %>% as.numeric()
initials[['Lcortime']] <- matrix(initials[['Lcortime']],
nrow = NC_dims,
ncol = NC_dims)
} # if(!is.null(initials[['Lcortime']])) {
# initialsxx <<- initials
#  print(str(initials))
# print(evaluated_priors)
#########
attr(evaluated_priors, 'initials') <- initials
attr(evaluated_priors, 'scode_auxillary') <- scode_auxillary
return(evaluated_priors)
}
.libPaths()[1]
packs = as.data.frame(installed.packages(.libPaths()[1]), stringsAsFactors = F)
packs
install.packages('cli’')
install.packages('cli’)
install.packages('cli')
remotes::install_github("Sandhu-SS/bsitar", auth_token = "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")
knitr::opts_chunk$set(
collapse = TRUE,
comment = NA,
message = FALSE,
warning = FALSE,
# eval = if (isTRUE(exists("params"))) params$EVAL else FALSE,
dev = "jpeg",
dpi = 100,
fig.asp = 0.8,
fig.width = 5,
out.width = "60%",
fig.align = "center"
)
# need to set_cmdstan_path otherwise build check package throws error
cmdstanr::set_cmdstan_path("//wsl$/Ubuntu/home/sandhu/.cmdstan/cmdstan-2.32.2")
library(tidyverse)
library(bsitar)
dirpath <- "E:\\wdR\\a_aaofl_sitar_nlme\\"
filedit <- "AAOF Collection Cephalometric Database Search 01.02.2022.csv"
paste0(dirpath, filedit)
mdataaof <- read.csv(paste0(dirpath, filedit))
data <- mdataaof %>%
`names<-` (tolower(names(.))) %>%
mutate(across(class, as.character)) %>%
mutate(class =str_replace(class, " ", "")) %>%
select(collection, subject, sex, class, age, copod, copad) %>%
mutate(copod = na_if(copod, "n/a")) %>%
mutate(copod = as.double(copod) )  %>%
mutate(copad = na_if(copad, "n/a")) %>%
mutate(copad = as.double(copad) )  %>%
arrange(collection, subject, age)  %>%
mutate(sex=recode(sex, "M" ="Male", "F" ="Female")) %>%
mutate(collection=str_replace_all(collection, "Growth" ,"")) %>%
mutate(collection=str_replace_all(collection, "Twin" ,"")) %>%
mutate(collection=str_replace_all(collection, "Longitudinal" ,"")) %>%
mutate(collection=str_replace_all(collection, "Bolton-Brush" ,"Bolton")) %>%
mutate(collection=str_trim(collection, side = c("both", "left", "right"))) %>%
group_by(collection) %>%
mutate(cid = cur_group_id())  %>%
group_by(collection, subject) %>%
mutate(id = cur_group_id()) %>%
ungroup() %>%
data.frame()
# select outcome
data <- data %>%
select(-c(cid, id)) %>%
rename(study = collection, id = subject) %>%
relocate(sex, study, class, id) %>%
mutate(across(c(sex, study, class, id), factor )) %>%
mutate(across(c(age, copad, copod), as.numeric )) %>%
drop_na(copod) %>%
mutate(class=recode(class,
'ClassI' = 'Class I',
'ClassII' = 'Class II',
'ClassIII' = 'Class III')) %>%
mutate(y = copod)
data_male <- data %>% filter(sex == 'Male') %>% droplevels()
# remove Fels with one male
data_male <- data_male %>% filter(study != 'Fels') %>% droplevels()
data_female <- data %>% filter(sex == 'Female') %>% droplevels()
################
data <- data %>% filter(class == 'Class I') %>% filter(age >= 6 & age <= 20)
data_male <- data_male %>% filter(class == 'Class I') %>% filter(age >= 6 & age <= 20)
data_female <- data_female %>% filter(class == 'Class I') %>% filter(age >= 6 & age <= 20)
###########
data_male <- data_male %>% tidyr::drop_na()
###########
# set initials for level 3 random effects
# This is only required when init is not random or 0
# when init are specified as init = random or init = 0,
# then these initials are not included
###########
# Get data to set dimensions of custom initials for level 3 sd and corr
sdata <- bsitar(x = age, y = list(copad, copod), id = id,
data = data_male,
df = list(4, 4), iter = 1000,
multivariate = T,
# xoffset = list(12, 12),
# bstart = list(12, 12),
a_prior_beta = normal( ymean, ysd, autoscale = 2.5),
b_prior_beta = normal( 0, 2.5, autoscale = 1),
c_prior_beta = normal( 0, 1.5, autoscale = 1),
s_prior_beta = normal( 0, lm, autoscale = 1),
a_formula_gr_str = list((1 | i |id:study) + (1 | s1 | study),
(1 | i |id:study) + (1 | s2 | study)
),
b_formula_gr_str = list((1 | i |id:study) + (1 | s1 | study),
(1 | i |id:study) + (1 | s2 | study)
),
c_formula_gr_str = list((1 | i |id:study) + (1 | s1 | study),
(1 | i |id:study) + (1 | s2 | study)
),
get_standata = T,
init = 0,
threads = threading(50, grainsize = 10),
control = list(adapt_delta = 0.95, max_treedepth = 15),
chains = 2,
sample_prior = 'only',
backend = 'rstan')
remotes::install_github("Sandhu-SS/bsitar", auth_token = "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")
remotes::install_github("Sandhu-SS/bsitar", auth_token = "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")
devtools::load_all(".")
roxygen2::roxygenise()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
load("heights_fit.RData")
heights_fit <- readRDS("~/GitHub/bsitar/heights_fit.rds")
usethis::use_data(heights_fit )
usethis::use_data_raw("heights_fit ")
sourceFolder <- function(folder, recursive = FALSE, ...) {
files <- list.files(folder, pattern = "[.][rR]$",
full.names = TRUE, recursive = recursive)
if (!length(files))
stop(simpleError(sprintf('No R files in folder "%s"', folder)))
src <- invisible(lapply(files, source, ...))
message(crayon::red(sprintf('\n%s file(s) sourced from folder "%s"', length(src), folder)))
print(list.files(folder))
}
sourceFolder("./R_bayespb")
usethis::use_data_raw()
usethis::use_data_raw("berkeley_fit")
usethis::use_data_raw("heights_fit")
CheckLazyDataCompression <- function(pkg)
{
pkg_name <- sub("_.*", "", pkg)
lib <- tempfile(); dir.create(lib)
zs <- c("gzip", "bzip2", "xz")
res <- integer(3); names(res) <- zs
for (z in zs) {
opts <- c(paste0("--data-compress=", z),
"--no-libs", "--no-help", "--no-demo", "--no-exec", "--no-test-load")
install.packages(pkg, lib, INSTALL_opts = opts, repos = NULL, quiet = TRUE)
res[z] <- file.size(file.path(lib, pkg_name, "data", "Rdata.rdb"))
}
ceiling(res/1024)
}
CheckLazyDataCompression(bsitar)
CheckLazyDataCompression('bsitar')
CheckLazyDataCompression()
remotes::install_github("Sandhu-SS/bsitar", auth_token = "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")
library(bsitar)
heights_fit
heights_fit %>% plot_bsitar()
heights_fit %>% fitted()
heights_fit %>% plot_bsitar()
library(bsitar)
?berkeley_fit
usethis::use_spell_check()
devtools::check()
remotes::install_github("Sandhu-SS/bsitar", auth_token = "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")
## code to prepare `berkeley_fit` dataset goes here
# library(magrittr)
library(bsitar)
data(berkeley, package = "sitar")
data <- berkeley
rm(berkeley)
data <- data %>%
dplyr::select(id, age, height, sex) %>%
dplyr::filter(age %in% c(6:20) ) %>%
tidyr::drop_na(height)
data$sex <- dplyr::recode_factor(data$sex, "1" = "Male", "2" = "Female")
data <- data %>%
sjmisc::to_dummy(sex, suffix = "label") %>%
dplyr::bind_cols(data,.) %>%
dplyr::mutate(Male = height, Female = height) %>%
dplyr::select(-height) %>%
dplyr::arrange(id, age, sex)
data <- data %>% dplyr::mutate(y = Male, id = as.factor(id) )
data <- data %>% dplyr::select(id, age, sex, y)
data <- data %>% dplyr::filter(sex == "Male")
# data %>% dplyr::glimpse()
# sitar::sitar(age, y, id, data=data, df=4)
# bsitar::
berkeley_fit <- bsitar(age, y, id, data=data,
chains = 4, iter = 2000,
sample_prior = 'no')
# usethis::use_data(berkeley_fit, overwrite = TRUE)
berkeley_fit
sitar::sitar(age, y, id, data=data, df=4)
berkeley_fitx <- berkeley_fit
berkeley_fit <- bsitar(age, y, id, data = data,
chains = 4, iter = 2000,
a_prior_beta = normal(0, 1000),
sample_prior = 'no')
library(bsitar)
berkeley_fit <- bsitar(age, y, id, data = data,
chains = 4, iter = 2000,
a_prior_beta = normal(0, 1000),
sample_prior = 'no')
sourceFolder <- function(folder, recursive = FALSE, ...) {
files <- list.files(folder, pattern = "[.][rR]$",
full.names = TRUE, recursive = recursive)
if (!length(files))
stop(simpleError(sprintf('No R files in folder "%s"', folder)))
src <- invisible(lapply(files, source, ...))
message(crayon::red(sprintf('\n%s file(s) sourced from folder "%s"', length(src), folder)))
print(list.files(folder))
}
sourceFolder("./R_bayespb")
sitar::outliers()
sitar::outliers
gt::gt
